### 项目初始化报错
1、gradle命令版本不对，检查电脑path环境变量配置
2、构建工具版本要跟开发工具里面的gradle的版本一致
3、删除gralde里面的build缓存，刷新依赖，重新构建，还是不行，重启开发工具

### 获取token失败。后台用长token请求成功，用短token失败。
移动端使用短token访问，后台需要解析成长token，后台使用的是第三方jar包，解析失败。

### 开发activity的时候，不继承base会闪退，云化版本没问题。
原因是base有主题设置，各个控件有的布局文件有引用这些配置，不集成的话，会找不到。
继承base或者添加这个主题。

### 图片加、载不一致，pc端和ios端是一样的，安卓原生浏览器不一样，自己的应用又不一样。
后台提供的图片地址是百度上面搜索给到的地址，里面很多乱码。需要对地址进行转码，并对一些字符进行替换处理。

### 主页点击后进详情，返回时显示空白
缓存逻辑处理问题。首先，缓存只存第一屏数据，并且是不为空，有数据的才缓存。页面显示的时候，需要对数据进行判空处理。
需要区分第一次加载，下拉加载，上拉加载，页面恢复的时候加载。

### 附件下载多次查看，提示文件格式错误，文件无法打开
原因是下载的时候加密了，设置为不加密。

### 附件下载多次查看，提示附件不存在
知识启动的时候，删除了文件夹，需要添加例外

### RMS文件打开失败，要提示无权限。
生成的rms文档，然后上云外网去打开怎么可能，不存在这种场景，服务器物理都是隔离的。

### 设置弹框的时候，控件宽高没有根据屏幕大小变化。
获取手机的宽高在初始化进行，切换横竖屏的时候，没有再次赋值。

### handle使用
1、handle使用静态类，并且弱引用。
2、发送消息使用十进制，禁用十六进制。
3、消息处理可以try，防止异常。
4、default:使用 break; 禁用super.handleMessage(msg);
5、子线程创建handle要调用Looper.prepare()，创建完成后要调用Looper.loop();//开启Looper的循环

### 上下文使用
尽量使用activity，安卓分屏适配要使用activity来startActivity，不能使用context否则会崩溃。

### 不继承base会闪退。
原因是base有主题设置，各个控件有的布局文件有引用这些配置，不集成的话，会找不到。
继承base或者不继承base，自主添加这个主题。

### long类型强转成int类型，会导致结果是负数
先确认到底是不是long类型，不要强转。

### 解决内存溢出：Out Of Memory---OOM
分配的内存不足以放下数据项序列,称为内存溢出。
1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 
2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 
3·死循环或递归调用
解决：
1、检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。
2、使用内存查看工具动态查看内存使用情况　
3、代码观察内存变动
Runtime.getRuntime().freeMemory();//可用内存
long use = total - free;//使用了的内存
4、对代码进行走查和分析，找出可能发生内存溢出的位置。
1）检查是否有一次获得全部数据的查询
2）检查代码中是否有死循环或递归调用
3）检查是否有大循环重复产生新对象实体
4）检查List、MAP等集合对象是否有使用完后，未清除的问题

### 解决内存泄露：Memory Leak
内存没有释放或者释放不完全，导致内存持续增加。到最后内存溢出。
1.单例导致对象不能回收
2.静态变量赋值大
3.handle(当非静态内部类对象的生命周期比外部类对象的生命周期长),消息在队列中未处理或者正在处理。
4.未取消注册或回调导致内存泄露
5.集合中的对象未清理造成内存泄露
6.WebView造成内存泄露
7.计时或循环任务一直运行，没有取消
8.listview没有复用，一直创建新对象
9.文件读写及时关闭
解决:
1、对异常进行监控、日志打印、日志上传到服务器，进行持续跟踪改进。
2、使用LeakCanary和Profiler工具进行分析。
3、在基类的onDestory方法中遍历view，进行资源清理，移除handler消息。各个页面销毁掉时候，要销毁各个监听。
4、再application中监控到内存低的时候，对资源进行清理。
5、图片加载使用565而不是888格式，宽高根据控件宽高展示，而不是屏幕宽高。
6、单例模式尽量使用application上下文。
7、Handler使用静态和弱引用，default的时候直接break掉。
8、内部类持有外部类引用的时候，将内部类静态化。
9、大数据传递的时候intent限制了大小，建议使用eventbus或者静态变量。
10、代码观察内存变动
Runtime.getRuntime().freeMemory();//可用内存
long use = total - free;//使用了的内存

### 应用程序无响应（ANR）
1、主线程做了很多耗时的操作
文件读写，复杂技术，数据库操作
2、死锁
发生死锁的线程一般处于MONITOR状态或者WAIT状态，等待其他进程的锁或者monitor，而其他进程又在等待另外线程的锁或者monitor，一直这样依赖下去，直到形成一个环。
3、主线程等待
发生ANR的主线程正处于monitor状态，也就是它在等待一个synchronized块或者方法，但是目前这个monitor正在被tid=11的线程持有，所以造成了主线程被阻塞，从而发生了ANR
4、耗时的动画

### 页面性能优化：
1、复杂布局：减少布局嵌套
2、过度绘制：可以开启手机过度绘制调试，找到该页面，减少背景色。背景色尽量放子view中
3、复杂操作：代码优化（减少对象创建，减少循环），放子线程执行复杂操作，主线程刷新ui。
4、提高显示速度,使用ViewStub：当加载的时候才会占用。

### 代码规范
1、程序结构清晰，简单易懂，单个函数的程序行数不得超过100行。
2、不要随意定义全局变量，尽量使用局部变量。
3、可读性第一，效率第二（命名规范，要有注释）
4、程序首先是正确，其次是优美
5、所以变量在调用前必须被初始化
6、对所有的用户输入，必须进行合法检查
7、慎重使用强转（long转int类型）
8、单元测试，自测
9、重复使用的完成相对独立功能的算法或代码应抽象为公共控件或类
10、公共控件或类应考虑面向对象思想，减少外界联系，考虑独立性或封装性
11、尽量在类中使用final，private修饰符
12、保证过期对象及时回收
13、尽量用的时候初始化或者加载，避免提前加载而用不到，导致内存消耗
14、重写equals和hashcode方法（特别是map集合）
15、采用对象池技术，提高对象的利用效率
16、尽量避免使用内在的Get,Set方法（应该直接调用）
17、判空
18、异常捕获

### 富文本编辑器方案有
1、原生使用span进行处理，但是耗性能，而且兼容性不好。
2、原生使用adapter，先定义好数据模型，根据用户输入内容来刷新列表数据，很难处理点击事件和焦点。
3、使用H5的富文本编辑器，也有兼容性问题需要处理。

### 富文本编辑器总结
1、写博客软键盘弹出监听和横竖屏切换使用OnGlobalLayoutListener
2、软键盘弹出会遮挡输入框，需要在弹出的时候监听布局高度，手动设置布局高度，并且防止多次调用。

###  H5富文本编辑器有图片内容的时候，有些输入法会联想出OBJ字符，替换前后的输入内容
解决方法：
创建IInputConnectionWrapper监听软键盘输入，及时替换OBJ。
光标后移，并且图片宽度全屏，这样输入的时候就不会在图片后面联想出OBJ了，
最终获取编辑器内容的时候需要替换OBJ，并且其他的输入框也要替换，因为用户可以复制编辑器内容粘贴到输入框。
H5富文本编辑器点击的时候，弹出软键盘，需要让编辑器滑动到点击位置。当点击在底部的时候，H5需要延时200才能滑动到底部。

### 输入法连接定位跟踪
IInputConnectionWrapper发送消息InputConnectionWrapper处理
点击联想输入
点击键盘按键输入
beginBatchEdit-setComposingText-endBatchEdit-getTextBeforeCursor-getTextAfterCursor
编辑器输入文字，有时候删除不了，因为不同的机器和不同的输入法对删除操作兼容不好，
需要监听IInputConnectionWrapper的 deleteSurroundingText 和 deleteSurroundingTextInCodePoints方法 来自行处理删除事件

### 控件销毁的方法onDetachedFromWindow里面不要随意进行销毁动作，会有异常
activity的生命是大于控件的，控件销毁了，activity不一定销毁，所以最好是放activity里面执行销毁操作。

### 写博客页面点击拍照返回写博客页面，会异常。
原因是拍照页面定义的风格是全屏，跟写博客页面不一样，导致重新设置页面的时候，高度设置为了0
写博客页面监听布局改变的时候，会出现多次。
拍照页面隐藏的时候onPause，写博客页面恢复onResume，布局监听生效。
拍照页面销毁的时候onDestroy，写博客页面布局监听生效。
需要在监听生效里面，处理高度为0的情况，为0的时候，不重新布局。

### IntentService
是Service的子类，继承IntentService的类至少要实现两个函数：构造函数和onHandleIntent()函数
（1）  它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents。
（2）  创建了一个工作队列，来逐个发送intent给onHandleIntent()。
（3）  不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。
（4）  默认实现的onBind()返回null
（5）  默认实现的onStartCommand()的目的是将intent插入到工作队列中

### handleThrow 异常处理或者异常捕获
整个应用自定义异常捕获：
实现异常捕获接口：Thread.UncaughtExceptionHandler
设置当前异常捕获对象：Thread.setDefaultUncaughtExceptionHandler(this);
处理异常信息：uncaughtException
常见异常有：空指针、数据越界、内存泄漏、资源id找不到

### Android中实现进程通信的方式
IPC定义：IPC是intent-Process Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。
通信的方式有：AIDL、Messager、ContentProvider、Socket、Bundle
AIDL：底层实现是Binder。我们只需要写好 aidl 接口文件，编译时系统会帮我们生成 Binder 接口。
AIDL 支持的数据类型：①Java 的基本数据类型②List 和 Map；③其他 AIDL 生成的接口；④实现 Parcelable 的实体
https://www.cnblogs.com/bugzone/p/aidl.html

Messager：底层实现是AIDL。我们可以在客户端发送一个Message给服务端，在服务端的handler中会接收到客户端的消息，然后进行对应的处理，处理完成后，再将结果等数据封装成Message，发送给客户端，客户端的handler中会接收到处理的结果。
支持回调的方式，也就是服务端处理完成长任务可以和客户端交互
不需要编写aidl文件
https://www.cnblogs.com/qlky/p/6731063.html

ContentProvider：底层实现是Binder。是Android中提供的专门用于不同应用间进行数据共享的方式，从这一点看，它天生就是和进程间通信。
https://blog.csdn.net/shaochen2015821426/article/details/79748487

Socket它分为流式套接字和用户数据套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议。TCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；而UDP是无连接的，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。在性能上，UDP具有更好的效率，其缺点是不保证数据一定能够正确传输，尤其是在网络繁重的时候。
https://blog.csdn.net/qq_38998213/article/details/89900211

 Bundle: 主要用于传递数据；它保存的数据，是以key-value(键值对)的形式存在的。
                Bundle bundle1 = new Bundle();
                // 把Persion数据放入到bundle中  
                bundle1.putSerializable("persion",persion);
                bundle1.putParcelable("persion",persion);
                Intent intent1=new Intent(MainActivity.this,Main2Activity.class);
                intent1.putExtras(bundle1);
                startActivity(intent1);
Bundle bundle=intent.getExtras();
 Persion persion= (Persion) bundle.getSerializable("persion");
 Persion persion= (Persion) bundle.getSerializableExtra("persion");

### Webview的加载优化
1、js文件放本地
2、js网络请求采用原生桥接
3、Webview提前创建好，使用的时候就从集合中去取，然后再addview到父布局。
public static List<Webview> webviewList = new ArrayList<>();
    private Webview getWebview() {
        if (webviewList.size() > 0) {
            for (Webview webview : webviewList) {
                if (webview.getParent() == null) {
                    //webview初始化
                    webview.init();
                    return webview;
                }
            }
        }
        Webview webview = new Webview(context);
        webview.init();
        webviewList.add(webview);
        return webview;
    }
4、原生提前请求服务数据，然后调用桥接，把数据给h5.

### React Native白屏优化
1、预加载,将ReactRootView提前创建，保存到静态集合中，需要的时候，通过从集合中去拿。
//RN的白屏问题就是出现在这里，两个比较耗时的函数分别为getReactNativeHost().getReactInstanceManager()和mReactRootView.startReactApplication，
  //预先缓存就是针对这里的，把这一步的操作，提前完成，然后用的时候，直接从内存开始加载
  protected void loadApp(String appKey) {
    if (mReactRootView != null) {
      throw new IllegalStateException("Cannot loadApp while app is already running.");
    }
    mReactRootView = createRootView();
    mReactRootView.startReactApplication(
      getReactNativeHost().getReactInstanceManager(),
      appKey,
      getLaunchOptions());
    getPlainActivity().setContentView(mReactRootView);
  }
2、设置默认背景，加载完成后再把背景去掉

### 有些古怪闪退，需要异常捕获
FragmentStatePagerAdapter类中   
    @Override
    public void restoreState(Parcelable state, ClassLoader loader) {
        try { //解决中英文切换后，返回主页面，闪退问题
            super.restoreState(state, loader);
        } catch (Exception e) {
            //do nothing
        }
    }

      try {
            Class<?> clz = item.getClass();
            Method m = clz.getMethod(GETPICKERVIEWTEXT);
            contentText = m.invoke(item, new Object[0]).toString();
        } catch (NoSuchMethodException e) {
        } catch (InvocationTargetException e) {
        } catch (IllegalAccessException e) {
        } catch (Exception e) {
        }

### 现在手机拍照出来的图片随便就大于20M了，图片上传很容易出问题。
1、获取图片宽高和存储大小，手机端提示用户不能上传。
2、后台放宽图片大小限制。
3、对图片宽高和质量进行等比压缩。压缩后的图片还是太大，再提示用户。

### listview的双向联动
1、自定义listview
2、建立全部变量的listview2并让外部设置
3、在ontouchevent方法中调用listview2的ontouchevent方法

### 锁对象
静态方法的锁对象是静态方法所在的类，非静态方法的锁对象是创建调用该方法的new对象。

### 快速识别h5页面
1、加载速度，h5会慢一点 2、看log日志打印，查看chrom的信息 3、在手机设置页面打开显示布局边界，h5页面是一整个布局

### aidl.exe'' finished with non-zero exit value 1
buildToolsVersion为29.0.0的时候报错，改成28.0.0。
* android studio编译含有AIDL文件项目里报此错误，是因为项目中的AIDL文件中有引用非JAVA基本数据类型的类，（此类的可能是用到你的方法形参类形）
* 解决方法： 只需要调用此类的形参类型前加 in    或是  out 即可，
如  void getError( in/out Context  context);

### apply from:"${android.sdkDirectory}/xx-ext/Util.gradle" 找不到
因为是系统开发，所以有底层的sdk修改，需要在sdk导入相关的文件夹

#### DevicePropertyUtil报错，找不到包android.telephony.FtTelephony和android.util.FtDeviceInfo
sdk缺失文件

### Could not find tools.jar. Please check that C:\Program Files\Java\jre1.8.0_144 contains a valid JDK installation.
查看jdk有没有tools.jar，没有就需要重新安装jdk。

### 手机连接不上云端
* 点击云端手机驱动安装
* 安装完成后，重启本地机和云端
* 点击云端设备打钩
* 打开手机的开发者模式进行手机连接，注意数据线和手机的插口稳定。
* 安装PC断手机助手，等待电脑给手机端安装手机助手。
* adb devices查看连接状态

### 很多文件提示找不到包
需要配置以下环境
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
 ext {
    compileSdkVersion = "android-28"
    minSdkVersion = 24
    targetSdkVersion = 26
    versionCode = 51200
    versionName = "5.3.2.0"
}
dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
}

### 在xxUtil.gradle文件的1031行报错：the LinkApplicationAndroidResourcesTask dons't genarate the HideRes.xml,please contact *** team!
* sdk不对
* 将gradle版本改成3.1.2
distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
 dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
    }

### git拉取代码的时候报错：Permission denied (publickey)
* git配置账号
git config --global user.name **osc（gerrit网站，路径Settings的名字）
git config --global user.email **osc@bbktel.com（gerrit网站，路径Settings的邮箱）
* 生成ssh key，并配置到gerrit（如果本地已经有ssh文件，就会生成不了）
a 使用ssh-keygen -t rsa -C "**osc@bbktel.com"命令生成ssh key（邮箱后缀为@bbktel.com）；
b 复制public key文件内容，public key路径如下：C:\Users\你的用户名\.ssh\id_rsa.pub；
c 将复制的public key粘贴到gerrit网站，路径Settings → SSH Public Keys → Add key；

### 报错：\src\main\res\drawable-440dpi: Error: Invalid resource directory name
* 删除drawable-440dpi
* SDk不对

### OEM切换报错端口找不到解决：
* 打开设备管理器，找到端口，核对Diagnostics(COM4)和NMEA 9025(COM6)
* 不对的话：右键属性-端口设置-高级-COM端口号改一下。
* 删掉无效的设备驱动：点击查看-显示隐藏的设备
* 点击扩大镜查找一下
* 联系系统管理员，进行远程的硬件端口核对
* 卸载驱动。

### git push代码的时候，提示：You are not allowed to perform this operation.
需要在android studio添加一个gerrit的插件，用这个插件提交才行。

### 代码冲突解决
* 产生原因：我提交代码到gerrit去审核，审核人觉得有问题，提出修改建议。我按照修改建议修改完成后，拉取代码，发现有人提交代码，并且跟我有冲突。
* git add  添加我需要提交的内容
* git commit –amend –no-edit  对上一次的提交进行修改，并且添加提交说明
* git push origin HEAD:  提交代码到审核分支
* 以上三个是没有冲突的情况下进行操作。当然此时，不拉取代码，就不会产生冲突。
* :q!  让前面的命令执行完毕，正常退出。不能直接关闭，不然上一个命令不能执行完毕。
* git merge --abort  将会抛弃合并过程并且尝试重建合并前的状态（危险操作）
* :q!  让前面的命令执行完毕，正常退出。不能直接关闭，不然上一个命令不能执行完毕。
* git show  显示各种类型的对象
* git remote update  管理一组跟踪的存储库。
* git rebase  在另一个分支基础之上重新应用，用于把一个分支的修改合并到当前分支。
* 这个时候会报红，显示冲突的文件。自己解决完冲突后继续，有可能自己改动的代码也回滚不见了，需要注意代码备份。
* git rebase --continue  
* git push origin HEAD:refs/changes/

### 安卓9.0，**手机webview加载闪退
1、app加固策略问题，app加固的so文件跟浏览器so文件冲突。
2、升级app，更新加固策略。
3、**手机的webview进行修复。

### 设置了点击效果的backgroud，可是点击没反应
viewgroup里面的子控件抢占焦点，或者设置了点击事件。

### 小程序的名称没有显示，显示的是号码
* 先卸载程序adb uninstall **
* 卸载已安装sso debug apk
* push 26号的sdk
* 核对是否push的是26号的sdk：adb shell ls -l system/priv-app/RcsSDK
* 拉最新代码运行安装Mms
* 开启融合通讯功能
* 手动新建会话，输入号码**，给这个号码发一条文本消息（内容随意）.退出会话，再进去，继续发消息，应该就会收到推送的内容。
* 核对输入号码是否有误。

























