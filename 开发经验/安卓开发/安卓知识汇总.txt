### <activity-alias> 标签的使用
通过<activity-alias> 标签为每个 Activity 注册一个“别名”, 通过这个别名就能启动对应的目标 Activity
重要的属性是:android:enabled 属性，布尔类型，是否开启别名设置，默认值为 true；
[Android 利用 <activity-alias> 动态改变 App 桌面图标](https://www.jianshu.com/p/5271d2b984bd)

### Android Studio各个构建版本使用
* gradle插件版本：gradle插件的版本号和gradle版本号是对应的，每个版本号又对应有一个或一些 Gradle发行版本（一般是限定一个最低版本,如gradle-4.1-all.zip）。
+ 调用Gradle本身的代码和批处理工具来构建项目
+ 调用Android SDK的编译、打包功能，所以跟buildToolsVersion有关。
[具体参考](https://developer.android.google.cn/studio/releases/gradle-plugin)
dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
}
* gradle发行版本：gradle文件夹下面的gradle-wrapper.properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
distributionBase和distributionPath组合在一起，是解压gradle-5.4.1-all.zip之后的文件的存放位置。 
zipStoreBase和distributionBase有两种取值：GRADLE_USER_HOME和PROJECT
GRADLE_USER_HOME表示用户目录，在windows下是%USERPROFILE%/.gradle，例如C:\Users\<user_name>\.gradle\。
PROJECT表示工程的当前目录，即gradlew所在的目录。
gradle-xx-all.zip是完整版，gradle-xx-bin.zip是二进制版，gradle-xx-src.zip是源码版
中间的目录名是根据distribution url路径字符串计算md5值得来的
[gradle-wrapper.properties中各属性的含义](https://blog.csdn.net/u013553529/article/details/55011602)
* compileSdkVersion 编译sdk的版本（对应sdk的platforms文件夹下面的版本），跟运行时要求的版本没关系。
* buildToolsVersion "28.0.0" 构建工作的版本（对应sdk的build-tools文件夹下面的版本）

### <xliff:g>标签介绍：
属性id可随意命名
%n$ms：输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格 
%n$md：输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格，也可以设为0m,在输出之前放置m个0 
%n$mf：输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为00.00
<resources xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2" <!-- 这里很重要 -->
        xmlns:tools="http://schemas.android.com/tools"
        tools:ignore="MissingTranslation">
    <string name="welcome">
            欢迎 <xliff:g id="name">%1$s</xliff:g>, 排名 <xliff:g id="num">%2$d</xliff:g>
    </string>
</resources>
String s = getString(R.string.welcome, "abc", 123);

### 为何Android使用Binder机制来实现进程间的通信？
* 可靠性：使用Client-Server的通信方式保证。linux支持跨进程通信有很多：管道、消息队列、共享内存、信号量，socket套接字，Binder。而只有只有socket和Binder支持Client-Server的通信方式。如果安卓在底层架设一套socket协议来实现Client-Server通信，增加了系统的复杂性。
* 传输性能：共享内存无需拷贝，但控制复杂。共享内存：0次。Binder：1次。Socket/管道/消息队列：2次（采用存储-转发方式，先缓存，再拷贝到接收方缓存区）。
* 安全性：Android对每一个安装应用都分配了UID/PID用来鉴别进程身份。传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信的IP地址是客户端手动填入，很容易进行伪造。

### 为什么Binder只进行了一次数据拷贝？
安卓将需要共享的数据copy_from_user()拷贝进内核空间，调用方通过mmap()映射方式进行调用。其他的方式是将共享数据拷贝进内核空间，再从内核将数据拷贝进调用方空间。

### Binder运行解释
[参考](http://gityuan.com/page2/)
Bunder通信的四个角色：Client进程，Server进程，Binder驱动（统计Server个数，对数据进行拷贝和共享，是ServiceManager进程的数据库），ServiceManager进程（负责跟这三方进行通信，ServiceManager是Client进程和Server进程的服务端）。
* 注册服务：启动前，Server进程先注册到ServiceManager。
* 获取服务：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。
* 使用服务：Client根据得到的Service信息建立与Server进程通信的通路，然后就可以直接与Service交互。该过程：Client是客户端，Server是服务端。
- Client通过获得一个Server的代理接口，对Server进行调用。
- 代理接口中定义的方法与Server中定义的方法是一一对应的。
- Client调用某个代理接口中的方法时，代理接口的方法会将Client传递的参数打包成Parcel对象。
- 代理接口将Parcel发送给内核中的Binder Driver。
- Server会读取Binder Driver中的请求数据，如果是发送给自己的，解包Parcel对象，处理并将结果返回。
- **整个的调用过程是一个同步过程，在Server处理的时候，Client会阻塞住。因此Client调用代理接口过程不应在主线程。**

### AIDL的具体使用
[参考](http://gityuan.com/page2/)
* 先在服务端创建AIDL
由于AIDL只支持数据类型:基本类型（int，long，char，boolean等），String，CharSequence，List，Map。**其他类型必须使用import导入，
即使它们可能在同一个包里，并加上in/out标记，如果其他类型是自定义的Parcelable对象，必须创建一个和它同名的AIDL文件，并在其中声明它为parcelable类型。**
 in 表示数据只能由客户端流向服务端。（表现为服务端修改此参数，不会影响客户端的对象）
 out 表示数据只能由服务端流向客户端。（表现为服务端收到的参数是空对象，并且服务端修改对象后客户端会同步变动）
 inout 则表示数据可在服务端与客户端之间双向流通。（表现为服务端能接收到客户端传来的完整对象，并且服务端修改对象后客户端会同步变动）
 oneway 关键字用于修改远程调用的行为，被oneway修饰了的方法不可以有返回值，也不可以有带out或inout的参数。
* Make Project ，SDK为自动为我们生成对应的Binder类。该接口中有个重要的内部类Stub ，继承了Binder 类，同时实现了IBookManager接口。 
* 服务端首先要创建一个Service用来监听客户端的连接请求。然后在Service中返回Stub类的实例。
* 客户端使用时，首先将服务端工程中的aidl文件夹下的内容整个拷贝到客户端工程的对应位置下
* 客户端绑定服务端的Service
Intent intentService = new Intent();
intentService.setAction("com.lvr.aidldemo.MyService");
intentService.setPackage(getPackageName());
intentService.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
this.bindService(intentService, mServiceConnection, BIND_AUTO_CREATE);
ServiceConnection mServiceConnection = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder binder) {
        //通过服务端onBind方法返回的binder对象得到IBookManager的实例，得到实例就可以调用它的方法了
        IBookManager mIBookManager = IBookManager.Stub.asInterface(binder);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        mIBookManager = null;
    }
};

### Service的onBind方法
[参考](http://gityuan.com/page2/)
当另一个组件想通过调用 bindService(intent, conn, Service.BIND_AUTO_CREATE) 与服务绑定时，Service将调用onBind方法。在此方法的实现中，必须返回 一个IBinder 接口的实现类，供客户端用来与服务进行通信。无论是启动状态还是绑定状态，此方法必须重写，但在启动状态的情况下直接返回 null。

### Service的unbindService(conn)方法
当解绑的时候，不会再回掉conn的onServiceDisconnected方法了，所以需要手动解绑：
if(mService!=null) {
    mService = null;
    unbindService(conn);
}

### Service的onCreate方法
首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或onBind() 之前）。如果服务已在运行，则不会调用此方法，该方法只调用一次。

### Service的onStartCommand方法
当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果自己实现此方法，则需要在服务工作完成后，通过调用 stopSelf() 或 stopService() 来停止服务。（在绑定状态下，无需实现此方法。）
Service.onStartCommand()的返回值：
* START_STICKY：如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。
* START_NOT_STICKY：“非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统将会把它置为started状态，系统不会自动重启该服务，直到startService(Intent intent)方法再次被调用;。
* START_REDELIVER_INTENT：重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。
* START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但不保证服务被kill后一定能重启。

### IntentService
可以看做是Service和HandlerThread的结合体，在完成了使命之后会自动停止，适合需要在工作线程处理UI无关任务的场景。
* IntentService 是继承自 Service 并处理异步请求的一个类，在 IntentService 内有一个工作线程来处理耗时操作。
* 当任务执行完后，IntentService 会自动停止，不需要我们去手动结束。
* 如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent（子线程方法）中执行，依次去执行，使用串行的方式，执行完自动结束。
* Intent intent = new Intent(IntentServiceActivity.this, MyIntentService.class); startService(intent);
* 使用场景描述：页面刷新进度条
- activity开启IntentService
- IntentService在onHandleIntent回调方法中执行网络请求，然后实时发生广播，广播携带进度参数
- activity中接收广播，更新进度条ui。

### HandlerThread
HandlerThread继承了Thread,它是一种可以使用Handler的Thread，它实现也很简单，就是在run中通过Looper.prepare()来创建消息队列，并且通过Looper.loop()来开启消息循环，这样再实际使用中就允许在HandlerThread中创建Handle了。

### 开启一个进程
android:process=":remote"设置为另一个进程
<service
    android:name=".MyService"
    android:process=":remote">
    <intent-filter>
        <category android:name="android.intent.category.DEFAULT" />
        <action android:name="com.lvr.aidldemo.MyService" />
    </intent-filter>
</service>

### Android Parcelable的使用
传值：mBundle.putParcelable(KEY, mPerson);
取值：Person mPerson = (Person)getIntent().getParcelableExtra(ParcelableTest.KEY);
       
### Launcher启动流程
* 每个应用都是单独的虚拟机和单独的进程。
* 概述：Loader > Kernel > Native > Framework > Application
* 细分：BootRom > Bootloader > Kernel > Init > Zygote > SystemServer > Launcher
- Loader层主要包括Boot Rom和Boot Loader
- Kernel层主要是Android内核层
- Native层主要是包括init进程以及其fork出来的用户空间的守护进程、HAL层、开机动画等
- Framework层主要是AMS和PMS等Service的初始化
- Application层主要指SystemUI、Launcher的启动
* 手机开机启动引导程序（Bootloader 就是在操作系统内核运行之前运行的一段小程序）：crt0.S（CPU初始化）>kmain（初始化内核）>arch_init（打印信息）> target_init（判断运行环境是否符合）>apps_init（应用功能初始化）>aboot_init（lcd驱动初始化，显示第一张图片）。
* Kernel初始化：zImage解压缩、kernel的汇编启动阶段、Kernel的C启动阶段。
* Init初始化：init进程是Linux内核启动后创建的第一个用户空间的进程，init在初始化过程中会启动很多重要的守护进程。
[具体参考](https://www.jianshu.com/p/657336b545bd)
* init进程会fork很多进程，包括zygote进程。（zygote进程是为了实现资源共用存在的，以后app启动出来的zygote进程都是第一个zygote进程的子进程。）
* zygote进程：创建安卓运行时环境，初始化图形系统，启动虚拟机，注册jni，之后执行java程序：创建ZogyteServer，创建本地socket服务，加载系统类和资源，fork出来system_server进程，启动应用进程main函数（Zygote的forkSystemServer方法返回进程）。
[具体参考](https://www.jianshu.com/p/e219c11d1620)
* SystemServer.java启动：
- 调整时间，如果系统时间比1970还要早，调整到1970年
- 设置语言
- 调整虚拟机堆内存大小和内存利用率
- 初始化Looper为mainLooper
- 装载库libandroid_server.so
- 初始化系统Context
- 创建SystemServiceManager负责系统Service启动
- 创建和启动Java服务
- 调用Looper.loop()，进入处理消息的循环
* 创建和启动Java服务：
- startBootstrapServices();
ActivityManagerService 核心服务，管理所有组件
PowerManagetService 电源管理服务
RecoverySystemService Recovery相关管理服务
LightsService 管理和控制光线传感器服务
DisplayManagerService 管理显示设备的服务
PackageManagerService 应用包管理服务
UserManagerService 管理用户的身份和信息的服务
- startCoreServices(); 
DropBoxManagerService 产生和管理系统日志文件的服务
BatteryService 监控电池状态的服务
- startOtherServices();
VibratorService 管理和控制震动设备的服务
AlarmManagerService 系统闹钟的服务 
InputManagerService 管理键盘和触摸输入的服务
BluetoothService 管理蓝牙设备的服务
InputMethodManagerService 提供输入法管理的服务
LockSettingsService 管理锁屏的服务
ClipboardService 系统剪切板的服务
NotificationManager 通知的服务
WallpaperManagerService 桌面背景的服务
UsbService 管理usb设备和连接的服务
这三个方法里面创建了系统里面重要的服务，并把它们纳入SystemServerManager的管理。
SystemServiceManager.startService创建service的实例，然后调用实例的onStart方法。
**所有实例start完毕后，也就是startOtherServices()方法执行最后，开始systemReady流程（mActivityManagerService.systemReady(new Runnable() ）。**
systemReady方法里面执行完WebViewFactory.prepareWebViewInSystemServer();之后执行startSystemUi(context);（启动SystemUIService），然后通过调用WindowManager的onSystemUiStarted方法调用KeyguardService启动锁屏服务。SystemUI启动成功后表示系统的通知栏和导航栏已经初始化成功。
在systemReady(final Runnable goingCallback) 方法中，先调用deliverPreBootCompleted发送开机广播，然后调用startHomeActivityLocked启动Launcher和HomeActivity。
[具体参考](https://www.jianshu.com/p/1adfd446e4fa)
[具体参考](https://blog.csdn.net/cj5785/article/details/78876118)
[具体参考](https://www.jianshu.com/p/4699d50deb99)

### app启动流程
* 点击桌面App图标发起startActivity请求：原Activity的onPause，新Activity的onCreate，新Activity的onStart，新Activity的onResume，原Activity的onStop，原Activity的onSaveInstanceState。
* Activity.startActivity(Intent).startActivity(Intent, Bundle).startActivityForResult(Intent, int, Bundle)==>
Instrumentation.execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)==>
ActivityManagerNative.getDefault() 返回 ActivityManagerProxy 对象==>
（原app的SystemServer客户端）
ActivityManagerProxy.startActivity(...)==>
mRemote.transact(...)==>
ActivityManagerNative.onTransact(int, Parcel, Parcel, int)进行 IPC 调用==>
（原app的SystemServer（客户端身份）==> 第一个zygote进程创建的SystemServer（服务端身份））
ActivityManagerService.startActivity(...).startActivityAsUser(...)==>
ActivityStackSupervisor.startActivityMayWait(...).startActivityLocked(...).startActivityUncheckedLocked(...)==>
ActivityStack.resumeTopActivityLocked(...).resumeTopActivityInnerLocked(...)==>
ActivityStackSupervisor.startSpecificActivityLocked(...).realStartActivityLocked(...)==>
app.thread.scheduleLaunchActivity(...)==>
ApplicationThreadNative。ApplicationThreadProxy#scheduleLaunchActivity(...)==>
mReote.transact(...)==>
ApplicationThreadNative.onTransact(...)进行 IPC 调用==>
（第一个zygote进程创建的SystemServer（客户端身份）==>新app的SystemServer（服务端身份），新app没有启动就会先启动再请求）
（新app的SystemServer服务端，以下认为新app已经启动）
ActivityThread.ActivityThread.ApplicationThread#scheduleLaunchActivity(...)
通过 Handler 发送消息 LAUNCH_ACTIVITY
ActivityThread$H#handleMessage(...).handleLaunchActivity(...).performLaunchActivity(...)==>
Activity.attach(...)==>
Instrumentation.callActivityOnCreate()==>
Activity.performCreate(...).onCreate(...)
[具体参考](https://www.jianshu.com/p/d1b08c184d55)
* 原app的SystemServer（客户端身份）通过binder IPC向第一个zygote进程创建的SystemServer（服务端身份）发送startActivity请求；
* AMS(system_server进程)接收到请求后，判断新app有没有启动，没有启动则通过socket向zygote进程发送创建进程的请求；
* Zygote进程fork出新的子进程，即App进程；
* App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；
* system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；
* App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；
* 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。
* 到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。

### 音视频播放
所有音视频播放都是ui层的绘制，调用的是第三方封装好的视频播放sdk，第三方的底层调用的是FFmpeg解码
所谓的音视频格式，其实就是文件后缀名，文件内容还是编码。
编码有各种协议，FFmpeg负责对这一块进行解码。
VideoActivity（或者MediaActivity）中的VideoView--WeLiveView--UVideoView--
merge.tv.danmaku.ijk.media.player.AndroidMediaPlayer（bilibili开源框架）--使用的是FFmpegApi解码（也是开源框架）
bilibili开源框架ijkmedia使用的是--安卓的android.media.MediaPlayer

### apk优化
* 小图标用svg图片，大图片用webp
https://developer.android.google.cn/studio/write/vector-asset-studio
 defaultConfig {
        vectorDrawables.useSupportLibrary = true
      }
  dependencies {
      compile 'com.android.support:appcompat-v7:23.2.0'
    }
  布局中使用：app:srcCompat="@drawable/ic_pic"
* tint着色器
同一张图片，点击的时候改变颜色，而不是两张图片。
创建一个selector1，里面设置item的drawable
创建一个selector2，里面设置item的color
在使用的imageview中设置android:src="@drawable/selector1',设置android:tint="@color/selector2'。
* 资源打包
defaultConfig {
  resConfigs("zh-rCN","ko")//逗号分隔，添加多个语言包
  }
* so库打包
互联网项目：使用'armeabi', 'armeabi-v7a'  或者问提供商要这两个的合并库。
传统项目（定制化项目）：
有的兼容安卓3.0就用v4。
mips和mips64库windows系统
x86库是32位模拟器
x86_64库主要是64位模拟器
    sourceSets{//将so库打包到apk内
        main{
            jniLibs.srcDirs=['libs']
        }
    }
defaultConfig {
  ndk {//配置so库架构（一般 真机：arm  模拟器：x86）
    abiFilters('armeabi', 'armeabi-v7a')
  }
}
* 移除无效资源
删除之前一定要备份代码，方便版本回归。
lint工具检查 Analyze--Run Inspection by Name--unused resource
* 代码混淆压缩
buildTypes{
  debug{
    // 源代码的压缩
    minifyEnabled true
  }
}
* 启用shrinkResources资源缩减，就不要第五项手动删除资源了。
buildTypes{
  debug{
    // 资源文件的压缩，没有用到的图片会变成占位图（几b的内存）
    shrinkResources true
  }
}
在res文件夹下面新建raw文件夹，再新建keep.xml文件，内容为：
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools"
  tools:discard="@color/color1"
  tools:keep="@drawable/pic1"
  tools:shrinkMode="stricts"/>
* webp转换插件-----图片变小
* 资源res文件混淆和7ZIP压缩

### Android之系统自带的文字外观设置
“android:textAppearance=“?android:attr/textAppearanceLargeInverse”这里引用的是系统自带的一个外观，？表示系统是否有这种外观，否则使用默认的外观。
可设置的值如下：textAppearanceButton/textAppearanceInverse/textAppearanceLarge/textAppearanceLargeInverse/textAppearanceMedium/
textAppearanceSmallInverse/textAppearanceMediumInverse/textAppearanceSmall/

### descendantFocusability解决焦点问题。
该属性有三种值：
beforeDescendants：viewGroup会优先其子类控件而获得焦点
afterDescendants：viewGroup会当其子控件不需要获得焦点时才获取焦点
blockDescendants：viewGroup会覆盖子类控件而直接获得焦点
* ListView的item有Button时，点击item无响应。
【根布局本身就是一个viewGroup】把item的根布局的属性设置为android：descendantFocusability=“blockDescendants”
* 在ScrollView时，里面包裹的内容超过了屏幕的长度，当进去scrollView直接自动滑动到最底部。
【父控件获得焦点，不把焦点传递给子控件】scrollView下面的ViewGroup中设置android：descendantFocusability为blockDescentants。

### 安卓build的生命周期
从上往下：
* setting.gradle执行gradle.settingsEvaluated {
    println "settings：执行settingsEvaluated..."
}
* setting.gradle执行gradle.projectsLoaded {
    println "settings：执行projectsLoaded..."
}
* setting.gradle执行gradle.beforeProject { proj ->
    println "settings：执行${proj.name} beforeProject"
}
* 外部build.gradle第一行执行
* 外部build.gradle执行task rootTest {
    println "根项目里任务配置---"
    doLast {
        println "执行根项目任务..."
    }
}
* 外部build.gradle的rootTest方法后执行
* setting.gradle执行gradle.afterProject { proj ->
    println "settings：执行${proj.name} afterProject"
}
settings：执行settingsEvaluated...
settings：执行projectsLoaded...
settings：执行test beforeProject
根项目配置开始---
根项目里任务配置---
根项目配置结束---
settings：执行test afterProject
settings：执行app beforeProject
子项目beforeEvaluate回调...
APP子项目配置开始---
APP子项目里任务配置---
APP子项目配置结束---
settings：执行app afterProject
APP子项目afterEvaluate回调...
settings: 执行projectsEvaluated...
构建结束...

### SensorManager安卓传感器
//获取SensorManager实例
sensorManager= (SensorManager) getSystemService(Context.SENSOR_SERVICE);
//获取当前设备支持的传感器列表
List<Sensor> allSensors = sensorManager.getSensorList(Sensor.TYPE_ALL);
* getName()//获取传感器名字
* getVendor()//获取传感器供应商
* getType()//获取传感器种类
Sensor.TYPE_ACCELEROMETER//加速度传感器
Sensor.TYPE_GYROSCOPE//陀螺仪传感器
Sensor.TYPE_LIGHT//光线传感器
Sensor.TYPE_MAGNETIC_FIELD//磁场传感器
Sensor.TYPE_ORIENTATION//方向传感器
Sensor.TYPE_PRESSURE//气压传感器
Sensor.TYPE_PROXIMITY//距离传感器
Sensor.TYPE_TEMPERATURE//温度传感器
* getVersion()//获取传感器版本
* getMaximumRange()//获取最大范围
* getResolution()//获取精度
* getPower()//传感器使用耗电量
* getMinDelay()//最小延时
* getFifoReservedEventCount()
* getFifoMaxEventCount()
* getStringType()

### PowerManager安卓电量管理
尽量避免使用这个类，并且使用完以后一定要及时释放。只要我们拿着这个锁， 那么系统就无法进入休眠状态。
* 添加权限：<!-- 允许应用在手机屏幕关闭后后台进程仍然运行 -->
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.DEVICE_POWER"/>
* 获取 WakeLock 对象：
PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
PowerManager的几个实用方法:
isScreenOn ()判断屏幕是否亮着（不管是暗的dimed还是正常亮度），在API20被弃用，推荐boolean PowerManager::isInteractive ()
goToSleep(long time)time是时间戳，一般是System.currentTimeMillis()+timeDelay。强制系统立刻休眠，需要Manifest中添加权限"android.permission.DEVICE_POWER"。按下电源键锁屏时调用的就是这个方法。
wakeUp(long time)唤醒屏幕。参数含义，所需权限与上同。按下电源键解锁屏幕时调用的就是这个方法。
reboot(String reason)重启手机，reason是要传给linux内核的参数，比如“recovery”重启进recovery模式，“fastboot”重启进fastboot模式。需要权限"android.permission.REBOOT"。
mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, getClass().getName());
* WakeLock的等级：
1.PARTIAL_WAKE_LOCK：保证CPU保持高性能运行，而屏幕和键盘背光（也可能是触摸按键的背光）关闭。一般情况下都会使用这个WakeLock。
2.ACQUIRE_CAUSES_WAKEUP：这个WakeLock除了会使CPU高性能运行外还会导致屏幕亮起，即使屏幕原先处于关闭的状态下。
3.ON_AFTER_RELEASE：如果释放WakeLock的时候屏幕处于亮着的状态，则在释放WakeLock之后让屏幕再保持亮一小会。如果释放WakeLock的时候屏幕本身就没亮，则不会有动作。
mWakeLock.acquire();//获得WakeLock
mWakeLock.release();//释放WakeLock
isHeld()//是否已经获取WakeLock
setReferenceCounted(boolean value)：//是否使用引用计数。类似于垃圾回收策略，只是把垃圾回收改成了WakeLock回收。

### android图片区域点击（图片热区）
com.peopledailychina.activity:id/mAreaImageView
com.hotimg.view.MapAreaView
[具体参考](https://blog.csdn.net/yq135314/article/details/84439921)
[具体参考](https://blog.csdn.net/DT235201314/article/details/78190492)
[具体参考](https://blog.csdn.net/qq_20082063/article/details/76021963)
[具体参考](https://blog.csdn.net/ausboyue/article/details/78267461)
[具体参考](https://blog.csdn.net/qq_28649655/article/details/89286445)
[具体参考](https://blog.csdn.net/DT235201314/article/details/78133932)
* 把要用的图片调整为合适的大小后（重要），导入到Dreamweaver中，在图片上，把需要添加事件的部分建立图片“热区”，然后映射到手机上的相应区域。
for(String key : keys) {
    idenId = mContext.getResources().getIdentifier(key, "array", mContext.getPackageName());
    int[] paths = mContext.getResources().getIntArray(idenId);
    idenId = mContext.getResources().getIdentifier(key + "_code", "array", mContext.getPackageName());
    String[] ptKeys = mContext.getResources().getStringArray(idenId);
    bodyArea = new MapArea(ptKeys, paths);
    mMapArea.put(key, bodyArea);
}
* 进行不同材质机器的兼容
private float toDip(Context context,float pxValue){
	final float scale = context.getResources().getDisplayMetrics().density;
	return (int) (pxValue * scale + 0.5f);
}
* 判断触摸点是否在热点区域
protected void checkAreas(MotionEvent event) {
        mFocus.clear();
	for(String key : mMapArea.keySet()) {
		mPathRectF.setEmpty();
		Path path = mMapArea.get(key).getPath();
		path.computeBounds(mPathRectF, true);
		if(mPathRectF.contains(event.getX(),event.getY())) {
			mFocus.add(key);
			break;
		}
	}
}

### LruCache的使用，以图片缓存为例
int maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);
int cacheSize = maxMemory/8;
mMemoryCache = new LruCache<String,Bitmap>(cacheSize){
    @Override
    protected int sizeOf(String key, Bitmap value) {
        return value.getRowBytes()*value.getHeight()/1024;
    }
};
* 设置LruCache缓存的大小，一般为当前进程可用容量的1/8。 
* 重写sizeOf方法，计算出要缓存的每张图片的大小。
**注意：缓存的总容量和每个缓存对象的大小所用单位要一致。**
* 成员变量有：size;//当前cache的大小，maxSize;//cache最大大小，putCount;//put的次数
* createCount;//create的次数，evictionCount;//驱逐剔除的次数，hitCount;//命中的次数，missCount;//未命中次数

### LruCache使用的是LinkedHashMap，LinkedHashMap的理解
* HashMap的两个属性Entry<K,V>  before,after。Entry的构造函数还有一个next指针，用于维护before,after的连接顺序。
* LinkedHashMap在HashMap功能上，增加Entry<K,V>  header(链表的头结点)，跟before,after组成一个双向链表，来实现按插入顺序或访问顺序排序。
* LinkedHashMap多线程不安全
* LinkedHashMap<>(0, 0.75f, true);构造函数的三个参数：初始容量,客座率，默认0.75f, true：基于访问顺序,默认是false，基于插入顺序
* true：基于访问顺序。最近访问的对象会被放到队尾，然后最后输出。
* LruCache正是用了LinkedHashMap的accessOrder=true构造参数实现LRU访问顺序。

### HandlerThread理解
* 使用：
//创建异步HandlerThread
HandlerThread handlerThread = new HandlerThread("downloadImage");
//必须先开启线程
handlerThread.start();
//子线程Handler
Handler childHandler = new Handler(handlerThread.getLooper(),new ChildCallback());
//每个1秒去更新图片
childHandler.sendEmptyMessageDelayed(i,1000*i);     
//该callback运行于子线程
class ChildCallback implements Handler.Callback {
    @Override
    public boolean handleMessage(Message msg) {
        //在子线程中进行网络请求
        Bitmap bitmap=downloadUrlBitmap(url[msg.what]);
        Message msg = mUIHandler.obtainMessage();
        msg.what = 1;
        msg.obj =bitmap;
        //通知主线程去更新UI
        mUIHandler.sendMessage(msg);
        return true;
    }
}
private static class UIHandler extends Handler {
    // 弱引用activity
    private WeakReference<Activity> mActivity;

    public UIHandler(Activity activity) {
        mActivity = new WeakReference<>(activity);
    }

    @Override
    public void handleMessage(Message msg) {
        UIActivity activity = (UIActivity) mActivity.get();
        if (activity == null || activity.isFinishing()) {
            return;
        }
        try {
            switch (msg.what) {
                case 1:
                    Log.d(TAG, "handleMessage");
                    if (msg.obj == null) {
                            return;
                    }
                    imageView.setImageBitmap((Bitmap)msg.obj);
                    break;
                default:
                    break;
            }
        } catch (Exception e) {
            Log.e(TAG, "handleMessage Exception: " + e.toString());
        }
    }
} 
* HandlerThread本质上是一个线程类，它继承了Thread；
* HandlerThread有自己的内部Looper对象，可以进行looper循环；
* 通过获取HandlerThread的looper对象传递给Handler对象，可以在handleMessage方法中执行异步任务。
* 创建HandlerThread后必须先调用HandlerThread.start()方法，Thread会先调用run方法，创建Looper对象。
* 需要在页面消耗的时候remove掉消息，避免内存泄漏

### AndroidX的使用
[参考](https://blog.csdn.net/qq_33721320/article/details/102981911)
[参考](https://developer.android.com/jetpack/androidx/migrate#artifact_mappings)
[迁移报错](https://blog.csdn.net/github_35186068/article/details/83929124)

### 切图
名称	        ldpi	    mdpi	    hdpi	    xhdpi   	xxhdpi	xxxhdpi(4k)
密度值	        120	160	    240	320	    480	640
分辨率	        240*320	    320*480	    480*800	    720*1080	1080*1920	2160*3840
程序启动图标	36*36	    48*48	     72*72	    96*96	     144*144	

### 电源管理
在低电耗模式下，您的应用会受到以下限制：
暂停访问网络。
系统忽略唤醒锁定。
标准 AlarmManager 闹钟（包括 setExact() 和 setWindow()）推迟到下一个维护期。
如果您需要设置在设备处于低电耗模式时触发的闹钟，请使用 setAndAllowWhileIdle() 或 setExactAndAllowWhileIdle()。
使用 setAlarmClock() 设置的闹钟将继续正常触发，系统会在这些闹钟触发之前不久退出低电耗模式。
系统不执行 WLAN 扫描。
系统不允许运行同步适配器。
系统不允许运行 JobScheduler。

在低电耗模式下测试您的应用
您可以按以下步骤在低电耗模式下测试您的应用：
使用 Android 6.0（API 级别 23）或更高版本的系统映像配置硬件设备或虚拟设备。
将设备连接到开发计算机并安装您的应用。
运行您的应用并使其保持活动状态。
运行以下命令，强制系统进入闲置模式：
    $ adb shell dumpsys deviceidle force-idle
准备就绪后，运行以下命令，使系统退出闲置模式：
    $ adb shell dumpsys deviceidle unforce
    打印Light state: ACTIVE, deep state: ACTIVE
执行以下命令，重新激活设备：
    $ adb shell dumpsys battery reset
在重新激活设备后观察应用的行为。确保应用在设备退出低电耗模式时正常恢复。

在应用待机模式下测试您的应用
如需在应用待机模式下测试您的应用，请执行以下操作：
使用 Android 6.0（API 级别 23）或更高版本的系统映像配置硬件设备或虚拟设备。
将设备连接到开发计算机并安装您的应用。
运行您的应用并使其保持活动状态。
运行以下命令，强制应用进入应用待机模式：
$ adb shell dumpsys battery unplug
    $ adb shell am set-inactive <packageName> true
使用以下命令模拟唤醒您的应用：
$ adb shell am set-inactive <packageName> false
    $ adb shell am get-inactive <packageName>
在唤醒应用后观察它的行为。确保应用从待机模式正常恢复。您应特别检查应用的通知和后台作业是否继续按预期运行。

 public static void testPowerManager(Context context) {
    final PowerManager powerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
//        powerManager.isRebootingUserspaceSupported();
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        // 如果设备当前处于空闲模式，则返回true。
        boolean isDeviceIdleMode = powerManager.isDeviceIdleMode();
        // 返回给定的应用程序包名称是否在设备的电源白名单中。
        boolean isIgnoringBatteryOptimizations = powerManager.isIgnoringBatteryOptimizations(context.getPackageName());
        boolean isInteractive = powerManager.isInteractive();
        // 如果设备当前处于省电模式，则返回true。
        boolean isPowerSaveMode = powerManager.isPowerSaveMode();
        LogUtils.d(TAG, "testPowerManager: isDeviceIdleMode:" + isDeviceIdleMode+"*isIgnoringBatteryOptimizations*"+
                isIgnoringBatteryOptimizations+"*isInteractive*"+isInteractive+"*isPowerSaveMode*"+isPowerSaveMode);
    }
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.N) {
        // 此功能检查设备是否已实现“持续性能模式”。
        boolean isSustainedPerformanceModeSupported = powerManager.isSustainedPerformanceModeSupported();
        LogUtils.d(TAG, "testPowerManager: isSustainedPerformanceModeSupported:" + isSustainedPerformanceModeSupported);
    }
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        // 此函数返回设备的当前热状态。
        int currentThermalStatus = powerManager.getCurrentThermalStatus();
        LogUtils.d(TAG, "testPowerManager: currentThermalStatus:" + currentThermalStatus);
        // 用于更改热状态，监听回调将被排队在主线程上的任务
        powerManager.addThermalStatusListener(new PowerManager.OnThermalStatusChangedListener(){

            @Override
            public void onThermalStatusChanged(int status) {
                powerManager.removeThermalStatusListener(this);
                LogUtils.d(TAG, "testPowerManager: addThermalStatusListener onThermalStatusChanged:" + status);
            }
        });
    }
}

### 保活
* 很早之前是双service守护，一个stop时启动另外一个。
* 监听开机广播，静态注册，被禁止了。
* 闹钟定时启动。
* jobservice长期运行，因为是系统服务。
* 接入厂商推送sdk，但是厂商限制免费推送次数。
* 发短信做活动，吸引用户使用。
* 系统应用保活：
* 双进程守护
* 账户管理定时同步

### 闹钟
alarmManager.set设置的时间不准，测试看到设置为20秒，实际为5秒。 
标准 AlarmManager 闹钟（包括 setExact() 和 setWindow()）推迟到下一个维护期。
如果您需要设置在设备处于低电耗模式时触发的闹钟，请使用 setAndAllowWhileIdle() 或 setExactAndAllowWhileIdle()。
使用 setAlarmClock() 设置的闹钟将继续正常触发，系统会在这些闹钟触发之前不久退出低电耗模式。

AlarmManager.ELAPSED_REALTIME：使用相对时间，可以通过SystemClock.elapsedRealtime() 获取（从开机到现在的毫秒数，包括手机的睡眠时间），设备休眠时并不会唤醒设备。
AlarmManager.ELAPSED_REALTIME_WAKEUP：与ELAPSED_REALTIME基本功能一样，只是会在设备休眠时唤醒设备。
AlarmManager.RTC：使用绝对时间，可以通过 System.currentTimeMillis()获取，设备休眠时并不会唤醒设备。
AlarmManager.RTC_WAKEUP: 与RTC基本功能一样，只是会在设备休眠时唤醒设备。

long triggerAtMillis = SystemClock.elapsedRealtime() + syncInterval;
long triggerAtMillis = System.currentTimeMillis() + syncInterval;
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
    alarmManager.setExactAndAllowWhileIdle(type, triggerAtMillis, pendingIntent);
} else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
    alarmManager.setExact(type, triggerAtMillis, pendingIntent);
} else {
    alarmManager.set(type, triggerAtMillis, pendingIntent);
}

### 安卓监听返回键，多任务键，home键
需要注意的是应用没有杀死广播就可以监听，返回键只有当前界面才可以。
* protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    //注意！！！在setContentView之前添加,未添加的话home键监听无效，设置窗体属性
    this.getWindow().setFlags(0x80000000, 0x80000000);
    setContentView(R.layout.**);
*   @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            //返回键
        }
        return super.onKeyDown(keyCode, event);
    }
*    private class InnerRecevier extends BroadcastReceiver {
        private static final String SYSTEM_DIALOG_REASON_KEY = "reason";
        private static final String SYSTEM_DIALOG_REASON_RECENT_APPS = "recentapps";
        private static final String SYSTEM_DIALOG_REASON_HOME_KEY = "homekey";

        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (!Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)) {
                return;
            }
            String reason = intent.getStringExtra(SYSTEM_DIALOG_REASON_KEY);
            if (SYSTEM_DIALOG_REASON_HOME_KEY.equals(reason)) {
                //Home键
            } else if (SYSTEM_DIALOG_REASON_RECENT_APPS.equals(reason)) {
                //多任务键
            }
        }
    }
*   //创建广播
    InnerRecevier innerReceiver = new InnerRecevier();
    //动态注册广播
    IntentFilter intentFilter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    //启动广播
    registerReceiver(innerReceiver, intentFilter);

### 监听通知栏下拉
* 通知栏会调用onWindowFocusChanged，不会调用onPause和onResume方法。
    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        LogUtils.d(TAG, "onWindowFocusChanged:" + hasFocus);
    }
* 辅助服务模式监听，耗性能，而且需要用户手动开启
继承AccessibilityService，在onAccessibilityEvent(AccessibilityEvent event)方法中，通过AccessibilityEvent来判断
if (accessibilityEvent.getEventType() == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED &&
    accessibilityEvent.getPackageName().equals("com.android.systemui") &&
    accessibilityEvent.getClassName().equals("com.android.systemui.statusbar.phone.PhoneStatusBar$ExpandedDialog") ||
    accessibilityEvent.getClassName().equals("android.widget.FrameLayout") ||
    accessibilityEvent.getClassName().equals("com.android.systemui.statusbar.StatusBarService$ExpandedDialog")) {
}

### 通知状态监听
NotificationListenerService主要方法(成员变量)：
cancelAllNotifications() ：删除系统中所有可被清除的通知； 
cancelNotification(String pkg, String tag, int id) ：删除具体某一个通知；
getActiveNotifications() ：返回当前系统所有通知到StatusBarNotification[]；
onNotificationPosted(StatusBarNotification sbn) ：当系统收到新的通知后出发回调； 
onNotificationRemoved(StatusBarNotification sbn) ：当系统通知被删掉后出发回调；
以上是NotificationListenerService的主要方法，通过这些方法就可以在应用中操作系统通知，在NotificationListenerService中除了对通知的操作之外，还可以获取到通知的StatusBarNotification对象，通过该对象可以获取通知更详细的数据。

StatusBarNotification主要方法(成员变量)：
getId()：返回通知对应的id；
getNotification()：返回通知对象；
getPackageName()：返回通知对应的包名；
getPostTime()：返回通知发起的时间；
getTag()：返回通知的Tag，如果没有设置返回null；
getUserId()：返回UserId，用于多用户场景；
isClearable()：返回该通知是否可被清楚，FLAG_ONGOING_EVENT、FLAG_NO_CLEAR；
isOngoing()：检查该通知的flag是否为FLAG_ONGOING_EVENT；
<service android:name=".MyNotificationListenService"  
         android:label="@string/service_name"  
         android:permission="android.permission.BIND_NOTIFICATION_LISTENER_SERVICE">  
    <intent-filter>  
        <action android:name="android.service.notification.NotificationListenerService" />  
    </intent-filter>  
</service>  

### ConstraintLayout（约束布局）、RelativeLayout（相对布局）、LinearLayout（线性布局）
线性布局会判断水平还是垂直布局，只测量一次。相对布局会水平和垂直测量两次。约束布局会测量多次（12次）。三者的耗时体现在测量次数。
当线性布局嵌套两层以上，建议使用相对布局。
当相对布局嵌套三层以上，建议使用约束布局。
Systrace会自动高亮这个布局的性能问题，以及一些修改它们的建议。https://developer.android.com/studio/profile/systrace.html

### singleTop和singleTask复用的时候
启动的activity不会走生命周期，会调用onNewIntent方法。

### 安卓跨进程通讯
* Activity、Broadcast、Service可以通过Intent传递
* Service还可以通过AIDL
bindService(new  Intent("net.blogjava.mobile.aidlservice.IMyService" ),  serviceConnection, Context.BIND_AUTO_CREATE);  
在ServiceConnection的onServiceConnected方法里面，myService = IMyService.Stub.asInterface(service); 再通过myService通信。
Service里面MyServiceImpl extends IMyService.Stub，然后在IBinder onBind(Intent intent)中return new MyServiceImpl();
MyServiceImpl中实现需要传递的数据。
* ContentProvider
- 调用端：
Uri uri = Uri.parse("content://com.example.test/query/single/keyword");  
Cursor cursor = getContentResolver().query(uri, null, "english=?", new String[]{ actvWord.getText().toString() }, null);
通过cursor来获取数据。
- 服务端继承ContentProvider 
- AndroidManifest.xml文件中<provider>标签中定义:
    <provider name=".TransportationProvider"  authorities="com.example.transportationprovider"   
          . . .  >  
- static {  
        //  添加访问ContentProvider的Uri   
        uriMatcher = new  UriMatcher(UriMatcher.NO_MATCH);  
        uriMatcher.addURI("com.example.test", "query/single/*", SINGLE_WORD);  
    }  
- 在onCreate创建SQLiteDatabase database = openDatabase(); 
- Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {  
    switch  (uriMatcher.match(uri))  {  
        case  SINGLE_WORD:  
            String word = uri.getPathSegments().get(1 );  
            cursor = database.rawQuery("select english as _id, chinese from t_words where english like %", new  String[]{word + "%"});   

### 线程池
* 创建
ThreadPoolExecutor mThreadPool = new ThreadPoolExecutor(40, 40, 1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(120), new ThreadFactory() {
    AtomicInteger mCount = new AtomicInteger(1);
    public Thread newThread(Runnable r) {
        String name = "ImapService #" + mCount.getAndIncrement();
        return new Thread(r, name);
    }
}, new ThreadPoolExecutor.AbortPolicy());
- 40：核心线程数
- 40：最大线程数
两个相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；
线程数量的设置没有一个明确的指标，根据实际情况，只要不是设置的偏大和偏小都问题不大，结合下面这个公式即可
    /**
    * Nthreads=最大线程数
    * Ncpu=CPU数量
    * Ucpu=目标CPU的使用率，0<=Ucpu<=1
    * W/C=任务等待时间与任务计算时间的比率
    */
Nthreads = Ncpu*Ucpu*(1+W/C)
- 1：线程空闲后最大存活时间，超过这个时间后会dead
- TimeUnit：时间单位
TimeUnit.DAYS          //天
TimeUnit.HOURS         //小时
TimeUnit.MINUTES       //分钟
TimeUnit.SECONDS       //秒
TimeUnit.MILLISECONDS  //毫秒
- BlockingQueue：线程等待队列，队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。
有直接提交队列、有界任务队列、无界任务队列、优先任务队列：
* 使用SynchronousQueue队列，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的进程，如果达到maximumPoolSize设置的最大值，则根据你设置的handler执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，而是会被马上执行，在这种情况下，你需要对你程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易就会执行拒绝策略；
* 使用ArrayBlockingQueue有界任务队列，若有新的任务需要执行时，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize，则执行拒绝策略。在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界队列初始容量较大或者没有达到超负荷的状态，线程数将一直维持在corePoolSize以下，反之当任务队列已满时，则会以maximumPoolSize为最大线程数上限。
* 使用LinkedBlockingQueue无界任务队列，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是你corePoolSize设置的数量，也就是说在这种情况下maximumPoolSize这个参数是无效的，哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，就不会再增加了；若后续有新的任务加入，则直接进入队列等待，当使用这种任务队列模式时，一定要注意你任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽，内存溢出的问题。
* 使用PriorityBlockingQueue它其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过corePoolSize的数量，只不过其他队列一般是按照先进先出的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。
该自定义规则为：
public class ThreadTask implements Runnable,Comparable<ThreadTask>{// 实现Comparable接口
public int compareTo(ThreadTask o) {// 重写compareTo方法，按线程优先级比较
    return  this.priority>o.priority?-1:1;
}
- ThreadFactory：线程创建工厂，默认的是DefaultThreadFactory。
可以按需要对线程池中创建的线程进行一些特殊的设置，如命名、优先级等
- RejectedExecutionHandler：拒绝策略，默认的是AbortPolicy策略。
AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；
CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行；
DiscardOledestPolicy策略：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的，马上要被执行的那个任务，并尝试再次提交；
DiscardPolicy策略：该策略会默默丢弃无法处理的任务，不予任何处理。当然使用此策略，业务场景中需允许任务的丢失；
以上内置的策略均实现了RejectedExecutionHandler接口，当然你也可以自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略
* 配置
mThreadPool.allowCoreThreadTimeOut(true);//当设置true时，允许核心线程超时后可以关闭。线程池没有任务的情况下，能销毁所有线程。
mThreadPool.execute(new Thread());
* submit和execute的区别
返回值不同execute返回void，submit返回Future，可以通过Future来查看线程状态。

### 多线程操作，怎么处理最终结果
* 多线程改单线程，依次执行。
* Rxjava
Observable<List<Topic>> observable1 = OkHttpUtils.getRetrofit().create(ApiService.class).loadTopicList(1);
Observable<List<New>> observable2 = OkHttpUtils.getRetrofit().create(ApiService.class).loadNewsList(1);
Observable<TopicsAndNews> observable = Observable.zip(observable1, observable2, new Func2<List<Topic>, List<New>, TopicsAndNews>() {
    @Override
    public TopicsAndNews call(List<Topic> topics, List<New> news) {
        TopicsAndNews topicsAndNews = new TopicsAndNews();
        topicsAndNews.setNews(news);
        topicsAndNews.setTopics(topics);
        return topicsAndNews;
    }
});
Subscriber<TopicsAndNews> subscriber = new DialogSubscriber<TopicsAndNews>(dialog) {
    @Override
    protected void onSuccess(TopicsAndNews topicsAndNews) {
        onLoadDatasListener.onSuccess(topicsAndNews);
    }

    @Override
    protected void onFailure(String msg) {
        onLoadDatasListener.onFailure(msg);
    }
};
observable.subscribeOn(Schedulers.io())
        .unsubscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(subscriber);
* 添加多个局部变量，先置为false，在各个线程执行完毕后，判断这些变量统一为true时，再处理。
* 使用锁，先wait，各个线程执行完毕后，各自调用notify，都notify了就会自动执行。
创建线程的构造函数时传入锁和list，并在线程内置为全局变量，总入口创建线程1，线程2，锁，list，从而实现list的同步。
需要注意的是lock.wait()地方要避免执行不全或者执行不到的问题（不要放到判断语句内，实在需要，可以多个地方wait或者死循环wait）。
* Condition是个接口，基本的方法就是await()和signal()方法
* 通过线程池submit方法拿到Future，future.get()来得到执行结果，get是堵塞的，会一直等待线程执行完毕，然后处理。
Future<String> future = mThreadPool.submit(new Runnable() {
    @Override
    public void run() {
    }
}, "test");
try {
    String test = future.get();
} catch (Throwable throwable) {
} 
* Kotlin协程处理并发
suspend fun one(): Int {
    delay(1500)
    return 1
}
suspend fun two(): Int {
    delay(1500)
    return 2
}
fun main() {
    GlobalScope.launch {
        /*measureTimeMillis返回给定的block代码的执行时间*/
        val time = measureTimeMillis {
            val sum = withContext(Dispatchers.IO) {
                val one = async { one() }
                val two = async { two() }
                one.await() + two.await()
            }
            println("两个方法返回值的和：${sum}")
        }
        println("执行耗时：${time}")
    }
    println("上面的协程代码并不会阻塞掉线程")
}
* 使用CountDownLatch
* 使用volatile和while语句轮询
给List添加volatile，一个线程执行List添加，另外一个线程B死循环判断集合大小，当判断成立后抛出异常中断循环，并进行捕获。

### swapper或sched的进程ID为0，负责分页，实际上是内核的一部分，而不是普通的用户模式进程。进程ID 1通常是初始化进程（init），主要负责启动和关闭系统

### onSaveInstanceState和onRestoreInstanceState
onSaveInstanceState 
当Activity可能被异常销毁，系统会调用onSaveInstanceState()方法来保存当前Activity的状态，这个方法的调用时机在onStop()之前，和onPause()没有既定的时序关系，可能在之前，也可能在之后调用
onRestoreInstanceState()
Activity被异常销毁后重新创建时，系统调用onRestoreInstanceState()，把onSaveInstanceState()之前所保存的Bundle对象作为参数传给onRestoreInstanceState()和onCreate()方法，进行数据和状态的恢复，按照时序上来说，onRestoreInstanceState()的调用时机在onStart()之后；
如果只是回到桌面，然后再返回。是会onSaveInstanceState，但是不会调用onRestoreInstanceState，所以设值最好再onResume

### CountDownLatch
countdownlatch 是一个同步类工具，不涉及锁定，当count的值为零时当前线程继续运行，不涉及同步，只涉及线程通信的时候，使用它较为合适
主线程main被end.await();阻塞，两个副线程继续往下运行，因为benin已经为0，所以不阻塞，操作两次end的downcount之后，主线程继续往下执行。如果不理解可以将线程数改成3试一下
注：end.countDown() 可以在多个线程中调用 计算调用次数是所有线程调用次数的总和

### 计算UI给的一张图片，在手机中实际占用内存大小
以一张112px*131px的图片（png和jpg格式）在1080px（宽）*1920px（高）像素的6英寸（对角线）手机为例：
屏幕大小：指屏幕对角线的长度，使用“寸”度量，如6英寸手机
分辨 率：分辨率指手机屏幕的像素点个数，如1080px（宽）*1920px（高）
每英寸像素：Pixels per Inch 又称为DPI（Dots Per Inch）,即屏幕密度，由对角线像素点数除以屏幕大小 得到，通常达到400PPI已经是非常高的屏幕密度
每英寸的像素 = 1080px*1080px+1920px*1920px 开平方后除以6=1166400+3686400=4852800开平方=2203/6=367
独立像素密度dp：density-independent pixel(密度无关像素)各种屏幕密度不同导致同样像素大小的长度，在不同密度的屏幕上的显示长度不同，
相同长度的屏幕高密度屏幕包含更多像素点，android 系统使用mdpi即密度值为160的屏幕作为标准，在这个屏幕上1px=1dp，
因此我们可以使用不同密度的比例计算出对应屏幕的px与dp比例关系。
dp/dip：全称是Density-independent pixel ，中文名是 “密度无关像素”  dip = px / (dpi / 160) 屏幕密度为160时，1px=1dp
各个文件夹对应的尺寸
assets（density是160，densityDpi是1倍）
drawable(density是160，densityDpi是1倍)，
drawable-ldpi（分辨率240*320，density是0-120，densityDpi是0.75倍），
drawable-mdpi（分辨率320*480，density是120-160，densityDpi是1倍），
drawable-hdpi（分辨率480*800，density是160-240，densityDpi是1.5倍），
drawable-xhdpi（分辨率720*1080，density是240-320，densityDpi是2倍），
drawable-xxhdpi（分辨率1080*1920，density是320-480，densityDpi是3倍），
drawable-xxxdpi（最高分辨率，density是480-640，densityDpi是4倍）
市面上大多数是1080*1920的手机了，一般设计也是在这个像素上面切图，对应文件夹是drawable-xxhdpi
112px*131px的png图片，图片格式是ARGB_8888，电脑上面显示20.57kb
实际程序加载的bitmap大小是:112*131*4 = 58688B，因为带有半透明，背景色会随控件背景色变化
Bitmap bitmap = BitmapFactoty.decodeStream(assets.open("11.jpg"));// 不设置，默认是8888
112px*131px的jpg图片，图片格式是RGB_565，电脑上面显示20.57kb
实际程序加载的bitmap大小是:112*131*2 = 29344，变小的原因是没有了A通道（半透明），背景默认是白色的了
Bitmap bitmap = BitmapFactoty.decodeStream(assets.open("11.jpg"), null, Option().also{
    it.inPreferredconfig = Bitmap.Config.RGB_565 
});
如果这张png图片是在drawable-xxhdpi（分辨率1080*1920，density是320-480，densityDpi是3倍）切的，
那在1080px（宽）*1920px（高）像素的6英寸手机的实际占用内存大小是：58688/3*（367/160）= 44799
367/160 = 2.29 是这台手机对应的实际倍数，对应的3倍是理论倍数。
看需要适配多少机型：需要适配720手机就切720图片，放drawable-xhdpi文件夹下面，1080切的图片就放drawable-xxhdpi文件夹下，不要放混和少图片就行。

### Loop
* 在安卓30中，子线程可以更新按钮和文本（存一度怀疑），但是不能弹框，调用Looper.prepare();和Looper.loop();就可以。
* 子线程调用Looper.prepare();和Looper.loop();更新UI，会导致该子线程无法销毁（因为Looper是死循环），从而堵塞线程池的队列，最终导致异常，触发线程池相应的策略。
* 一个应用可以有多个进程，一个进程只有一个主线程，一个主线程(也叫UI线程)只有一个Looper。一个线程只能有一个Looper，多个线程可以有多个Looper。
* Looper是MessageQueue的管理者。每一个MessageQueue都不能脱离Looper而存在，Looper对象的创建是通过prepare函数来实现的。同时每一个Looper对象和一个线程关联。

### Android如何保证一个线程最多只能有一个Looper？
* Looper的构造方法为private，所以不能直接使用其构造方法创建。
若在已有Looper的线程中调用Looper.prepare()会抛出RuntimeException(“Only one Looper may be created per thread”)。
* prepare()方法中调用了ThreadLocal的get和set方法实现线程安全，所以整个过程没有添加同步锁。
可以将ThreadLocal理解为一块存储区，将这一大块存储区分割为多块小的存储区，每一个线程拥有一块属于自己的存储区，那么对自己的存储区操作就不会影响其他线程。对于ThreadLocal<Looper>，则每一小块存储区中就保存了与特定线程关联的Looper。

### Android中为什么主线程不会因为Looper.loop()里的死循环卡死？（Linux的pipe/epoll机制）
在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，
此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。
这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，
本质同步I/O，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。

### 主线程和子线程通信
* 主线程创建Handler，Handler会自动关联主线程的Looper和MessageQueue（每个线程只有一个）。
* 子线程调用 mHandler.sendMessage(message);的时候，最终调用enqueueMessage，将message放入MessageQueue
* 而主线程的Looper会死循环，监听到有消息时，会主动从MessageQueue中取，从而实现了通信。

### 子线程和子线程中使用Handler通信
* 在子线程1中创建Handler1，在子线程2中通过Handler1发送消息，在Handler1的handleMessage就是子线程1的执行。
* 要子线程创建Handler：
- Handler handler = new Handler(Looper.getMainLooper());// 还是主线程的Handler
- Handler handler = new Handler(Looper.myLooper());// 子线程的Handler
- Looper.prepare();Handler handler = new Handler();Looper.loop();// 子线程的Handler
* 但是没法实现信息交互，就像主线程和子线程一样，主线程没法将获取到的message再处理后传值给子线程。（只能加锁等待）

### Looper
* Looper.loop();后面的代码不会执行，因为Looper.loop();会堵塞线程，需要先调用quit退出才能执行。
handler.getLooper().quit();或者Looper.myLooper().quit();// 参考HandlerThread
* Looper.loop();会堵塞线程，因为此时子程序已经切换到了主线程，从而可以在Looper.prepare()后执行UI操作。而且必须Looper.loop();才能真正显示。
* 每个线程只有一个Looper，是通过ThreadLocal来保证的，ThreadLocal会是线程的暂存区域。当线程创建Looper的时候会判断ThreadLocal是否有了，有的话会抛异常。
if (sThreadLocal.get() != null) 
    throw new RuntimeException("Only one Looper may be created per thread");

### 上下文
Activity继承ContextThemeWrapper继承ContextWrapper继承Context
Application继承ContextWrapper继承Context
Service继承ContextWrapper继承Context
PhoneWindow继承Window，由WindowManagerService管理
DecorView继承FrameLayout，由PhoneWindow拿到ViewRootImpl进行管理，是所有应用窗口的根View 。
每一个Activity都包含一个Window对象，Window对象通常由PhoneWindow实现。该类是一个抽象类，提供了绘制窗口的一组通用API。可以将之理解为一个载体，各种View在这个载体上显示。
PhoneWindow内部包含了一个DecorView对象。DectorView对象是所有应用窗口(Activity界面)的根View。 PhoneWindow类是把一个FrameLayout类即DecorView对象进行一定的包装，将它作为应用窗口的根View，并提供一组通用的窗口操作接口。

### RecycleView

### 事件分发

### Rxjava的使用

### 组件化调用

### 音视频开发

### handler的post和send执行流程
会一步步判空，最终执行

### livedata底层还是handler,会出现post执行不到位的情况，第一次不生效，第二次才生效

### 直接从栈内恢复页面
          ActivityManager mAm = (ActivityManager) CommonAppContext.sInstance.getSystemService(Context.ACTIVITY_SERVICE);
            //获得当前运行的task
            List<ActivityManager.RunningTaskInfo> taskList = mAm.getRunningTasks(100);
            for (ActivityManager.RunningTaskInfo rti : taskList) {
                //找到当前应用的task，并启动task的栈顶activity，达到程序切换到前台
                if (rti.topActivity.getPackageName().equals(CommonAppContext.sInstance.getPackageName())) {
                    mAm.moveTaskToFront(rti.id, 0);
                    break;
                }
            }













































