
#线程调度模型
分时调度模型：轮流获取，均分CPU时间
抢占式调度模型：优先级高的获取，JVM采用

Android
1. nice值
在process中定义； 值越小，优先级越高； 默认是THREAD_PRIORITY_DEFAULT,0

2. cgroup
更严格的群组调度策略；保证前台线程可以获取到更多的CPU; 
后台group: 优先级比较低的线程；不在前台运行的应用程序的线程

注意点
线程过多会导致CPU频繁切换，降低线程运行效率；正确认识任务重要性，决定哪种优先级；优先级具有继承性；


#异步方式
1. Thread
2. HandlerThread
   自带消息循环的线程； 串行执行； 长时间运行，不断从队列中获取任务
3. IntentService
   继承自Service在内部创建HandlerThread; 异步，不占用主线程；优先级较高，不易被系统kill
4. AsyncTask
   Android 提供的工具类；无需自己处理线程切换；需注意版本不一致问题
5. 线程池
   java提供的线程池；易复用，减少频繁创建、销毁的时间；功能强大：定时、任务队列、并发数控制等
6. RxJava
   由强大的Scheduler集合提供；不同类型的区分：IO、Computation


#线程使用准则
1. 严禁直接new Thread
2. 提供基础线程池供各个业务线使用：
    避免各个业务线各自维护一套线程池，导致线程数过多
3. 根据任务类型选择合适的异步方式：
    优先级低，长时间运行，HandlerThread
4. 创建线程时必须命名： 
    方便定位线程归属；运行期Thread.currentThread().setName()修改名字;
5. 关键异步任务监控： 
    异步不等于不耗时
6. 重视优先级设置： 
    Process.setThreadPriority(); 可以设置多次

#锁定线程创建者
背景：
项目变大之后 收敛线程
项目源码、三方库、aar中都有线程的创建

方案：
创建线程的位置获取堆栈
所有的异步方式，都会走到new Thread()方法

使用Hook手段；
找Hook点： 构造函数或者特点方法
Thread的构造函数

~
~



#统一线程库
1. 区分任务类型
    IO密集型任务：不消耗CPU， 核心池可以很大
    CPU密集型任务：核心池大小和CPU核心数相关


问题
1. 线程使用为什么会遇到问题
   项目开发初期，没有注意基础库的建设，没有使用统一线程池
   问题：主线程卡顿，后台线程执行耗时，
   原因：java是一个抢占式的线程调度模型，所以线程优先级比较重要，针对IO、CPU密集型的任务要做区分

2. 怎么在项目中 对线程进行优化
    线程收敛： 解决线程数量过多的问题，采用Hook手段 找到每个线程创建的堆栈信息，分析线程创建的合理性
            从业务层面，将线程创建 收敛到统一的线程池基础库当中
    统一线程池：针对IO、CPU密集型的任务要做区分； 根据CPU核心数量 计算CPU密集型任务的线程池大小
    其他细节： 对重要的异步逻辑进行监控，监控执行时间；在执行异步任务时注重对优先级 以及线程名称的设置



