### <activity-alias> 标签的使用
通过<activity-alias> 标签为每个 Activity 注册一个“别名”, 通过这个别名就能启动对应的目标 Activity
重要的属性是:android:enabled 属性，布尔类型，是否开启别名设置，默认值为 true；
[Android 利用 <activity-alias> 动态改变 App 桌面图标](https://www.jianshu.com/p/5271d2b984bd)

### Android Studio各个构建版本使用
* gradle插件版本：gradle插件的版本号和gradle版本号是对应的，每个版本号又对应有一个或一些 Gradle发行版本（一般是限定一个最低版本,如gradle-4.1-all.zip）。
+ 调用Gradle本身的代码和批处理工具来构建项目
+ 调用Android SDK的编译、打包功能，所以跟buildToolsVersion有关。
[具体参考](https://developer.android.google.cn/studio/releases/gradle-plugin)
dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
}
* gradle发行版本：gradle文件夹下面的gradle-wrapper.properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
distributionBase和distributionPath组合在一起，是解压gradle-5.4.1-all.zip之后的文件的存放位置。 
zipStoreBase和distributionBase有两种取值：GRADLE_USER_HOME和PROJECT
GRADLE_USER_HOME表示用户目录，在windows下是%USERPROFILE%/.gradle，例如C:\Users\<user_name>\.gradle\。
PROJECT表示工程的当前目录，即gradlew所在的目录。
gradle-xx-all.zip是完整版，gradle-xx-bin.zip是二进制版，gradle-xx-src.zip是源码版
中间的目录名是根据distribution url路径字符串计算md5值得来的
[gradle-wrapper.properties中各属性的含义](https://blog.csdn.net/u013553529/article/details/55011602)
* compileSdkVersion 编译sdk的版本（对应sdk的platforms文件夹下面的版本），跟运行时要求的版本没关系。
* buildToolsVersion "28.0.0" 构建工作的版本（对应sdk的build-tools文件夹下面的版本）

### <xliff:g>标签介绍：
属性id可随意命名
%n$ms：输出的是字符串，n代表是第几个参数，设置m的值可以在输出之前放置空格 
%n$md：输出的是整数，n代表是第几个参数，设置m的值可以在输出之前放置空格，也可以设为0m,在输出之前放置m个0 
%n$mf：输出的是浮点数，n代表是第几个参数，设置m的值可以控制小数位数，如m=2.2时，输出格式为00.00
<resources xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2" <!-- 这里很重要 -->
        xmlns:tools="http://schemas.android.com/tools"
        tools:ignore="MissingTranslation">
    <string name="welcome">
            欢迎 <xliff:g id="name">%1$s</xliff:g>, 排名 <xliff:g id="num">%2$d</xliff:g>
    </string>
</resources>
String s = getString(R.string.welcome, "abc", 123);

### 为何Android使用Binder机制来实现进程间的通信？
* 可靠性：使用Client-Server的通信方式保证。linux支持跨进程通信有很多：管道、消息队列、共享内存、信号量，socket套接字，Binder。而只有只有socket和Binder支持Client-Server的通信方式。如果安卓在底层架设一套socket协议来实现Client-Server通信，增加了系统的复杂性。
* 传输性能：共享内存无需拷贝，但控制复杂。共享内存：0次。Binder：1次。Socket/管道/消息队列：2次（采用存储-转发方式，先缓存，再拷贝到接收方缓存区）。
* 安全性：Android对每一个安装应用都分配了UID/PID用来鉴别进程身份。传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信的IP地址是客户端手动填入，很容易进行伪造。

### 为什么Binder只进行了一次数据拷贝？
安卓将需要共享的数据copy_from_user()拷贝进内核空间，调用方通过mmap()映射方式进行调用。其他的方式是将共享数据拷贝进内核空间，再从内核将数据拷贝进调用方空间。

### Binder运行解释：
Bunder通信的四个角色：Client进程，Server进程，Binder驱动（统计Server个数，对数据进行拷贝和共享，是ServiceManager进程的数据库），ServiceManager进程（负责跟这三方进行通信，ServiceManager是Client进程和Server进程的服务端）。
* 注册服务：启动前，Server进程先注册到ServiceManager。
* 获取服务：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。
* 使用服务：Client根据得到的Service信息建立与Server进程通信的通路，然后就可以直接与Service交互。该过程：Client是客户端，Server是服务端。
- Client通过获得一个Server的代理接口，对Server进行调用。
- 代理接口中定义的方法与Server中定义的方法是一一对应的。
- Client调用某个代理接口中的方法时，代理接口的方法会将Client传递的参数打包成Parcel对象。
- 代理接口将Parcel发送给内核中的Binder Driver。
- Server会读取Binder Driver中的请求数据，如果是发送给自己的，解包Parcel对象，处理并将结果返回。
- **整个的调用过程是一个同步过程，在Server处理的时候，Client会阻塞住。因此Client调用代理接口过程不应在主线程。**

### AIDL的具体使用
* 先在服务端创建AIDL
由于AIDL只支持数据类型:基本类型（int，long，char，boolean等），String，CharSequence，List，Map。**其他类型必须使用import导入，即使它们可能在同一个包里，并加上in/out标记，如果其他类型是自定义的Parcelable对象，必须创建一个和它同名的AIDL文件，并在其中声明它为parcelable类型。**
* Make Project ，SDK为自动为我们生成对应的Binder类。该接口中有个重要的内部类Stub ，继承了Binder 类，同时实现了IBookManager接口。 
* 服务端首先要创建一个Service用来监听客户端的连接请求。然后在Service中返回Stub类的实例。
* 客户端使用时，首先将服务端工程中的aidl文件夹下的内容整个拷贝到客户端工程的对应位置下
* 客户端绑定服务端的Service
Intent intentService = new Intent();
intentService.setAction("com.lvr.aidldemo.MyService");
intentService.setPackage(getPackageName());
intentService.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
this.bindService(intentService, mServiceConnection, BIND_AUTO_CREATE);
ServiceConnection mServiceConnection = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder binder) {
        //通过服务端onBind方法返回的binder对象得到IBookManager的实例，得到实例就可以调用它的方法了
        IBookManager mIBookManager = IBookManager.Stub.asInterface(binder);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        mIBookManager = null;
    }
};

### Service的onBind方法
当另一个组件想通过调用 bindService(intent, conn, Service.BIND_AUTO_CREATE) 与服务绑定时，Service将调用onBind方法。在此方法的实现中，必须返回 一个IBinder 接口的实现类，供客户端用来与服务进行通信。无论是启动状态还是绑定状态，此方法必须重写，但在启动状态的情况下直接返回 null。

### Service的unbindService(conn)方法
当解绑的时候，不会再回掉conn的onServiceDisconnected方法了，所以需要手动解绑：
if(mService!=null) {
    mService = null;
    unbindService(conn);
}

### Service的onCreate方法
首次创建服务时，系统将调用此方法来执行一次性设置程序（在调用 onStartCommand() 或onBind() 之前）。如果服务已在运行，则不会调用此方法，该方法只调用一次。

### Service的onStartCommand方法
当另一个组件（如 Activity）通过调用 startService() 请求启动服务时，系统将调用此方法。一旦执行此方法，服务即会启动并可在后台无限期运行。 如果自己实现此方法，则需要在服务工作完成后，通过调用 stopSelf() 或 stopService() 来停止服务。（在绑定状态下，无需实现此方法。）
Service.onStartCommand()的返回值：
* START_STICKY：如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。
* START_NOT_STICKY：“非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统将会把它置为started状态，系统不会自动重启该服务，直到startService(Intent intent)方法再次被调用;。
* START_REDELIVER_INTENT：重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。
* START_STICKY_COMPATIBILITY：START_STICKY的兼容版本，但不保证服务被kill后一定能重启。

### IntentService
可以看做是Service和HandlerThread的结合体，在完成了使命之后会自动停止，适合需要在工作线程处理UI无关任务的场景。
* IntentService 是继承自 Service 并处理异步请求的一个类，在 IntentService 内有一个工作线程来处理耗时操作。
* 当任务执行完后，IntentService 会自动停止，不需要我们去手动结束。
* 如果启动 IntentService 多次，那么每一个耗时操作会以工作队列的方式在 IntentService 的 onHandleIntent（子线程方法）中执行，依次去执行，使用串行的方式，执行完自动结束。
* Intent intent = new Intent(IntentServiceActivity.this, MyIntentService.class); startService(intent);
* 使用场景描述：页面刷新进度条
- activity开启IntentService
- IntentService在onHandleIntent回调方法中执行网络请求，然后实时发生广播，广播携带进度参数
- activity中接收广播，更新进度条ui。

### HandlerThread
HandlerThread继承了Thread,它是一种可以使用Handler的Thread，它实现也很简单，就是在run中通过Looper.prepare()来创建消息队列，并且通过Looper.loop()来开启消息循环，这样再实际使用中就允许在HandlerThread中创建Handle了。

### 开启一个进程
android:process=":remote"设置为另一个进程
<service
    android:name=".MyService"
    android:process=":remote">
    <intent-filter>
        <category android:name="android.intent.category.DEFAULT" />
        <action android:name="com.lvr.aidldemo.MyService" />
    </intent-filter>
</service>

### Android Parcelable的使用
传值：mBundle.putParcelable(KEY, mPerson);
取值：Person mPerson = (Person)getIntent().getParcelableExtra(ParcelableTest.KEY);
       
### Launcher启动流程
* 每个应用都是单独的虚拟机和单独的进程。
* 概述：Loader > Kernel > Native > Framework > Application
* 细分：BootRom > Bootloader > Kernel > Init > Zygote > SystemServer > Launcher
- Loader层主要包括Boot Rom和Boot Loader
- Kernel层主要是Android内核层
- Native层主要是包括init进程以及其fork出来的用户空间的守护进程、HAL层、开机动画等
- Framework层主要是AMS和PMS等Service的初始化
- Application层主要指SystemUI、Launcher的启动
* 手机开机启动引导程序（Bootloader 就是在操作系统内核运行之前运行的一段小程序）：crt0.S（CPU初始化）>kmain（初始化内核）>arch_init（打印信息）> target_init（判断运行环境是否符合）>apps_init（应用功能初始化）>aboot_init（lcd驱动初始化，显示第一张图片）。
* Kernel初始化：zImage解压缩、kernel的汇编启动阶段、Kernel的C启动阶段。
* Init初始化：init进程是Linux内核启动后创建的第一个用户空间的进程，init在初始化过程中会启动很多重要的守护进程。
[具体参考](https://www.jianshu.com/p/657336b545bd)
* init进程会fork很多进程，包括zygote进程。（zygote进程是为了实现资源共用存在的，以后app启动出来的zygote进程都是第一个zygote进程的子进程。）
* zygote进程：创建安卓运行时环境，初始化图形系统，启动虚拟机，注册jni，之后执行java程序：创建ZogyteServer，创建本地socket服务，加载系统类和资源，fork出来system_server进程，启动应用进程main函数（Zygote的forkSystemServer方法返回进程）。
[具体参考](https://www.jianshu.com/p/e219c11d1620)
* SystemServer.java启动：
- 调整时间，如果系统时间比1970还要早，调整到1970年
- 设置语言
- 调整虚拟机堆内存大小和内存利用率
- 初始化Looper为mainLooper
- 装载库libandroid_server.so
- 初始化系统Context
- 创建SystemServiceManager负责系统Service启动
- 创建和启动Java服务
- 调用Looper.loop()，进入处理消息的循环
* 创建和启动Java服务：
- startBootstrapServices();
ActivityManagerService 核心服务，管理所有组件
PowerManagetService 电源管理服务
RecoverySystemService Recovery相关管理服务
LightsService 管理和控制光线传感器服务
DisplayManagerService 管理显示设备的服务
PackageManagerService 应用包管理服务
UserManagerService 管理用户的身份和信息的服务
- startCoreServices(); 
DropBoxManagerService 产生和管理系统日志文件的服务
BatteryService 监控电池状态的服务
- startOtherServices();
VibratorService 管理和控制震动设备的服务
AlarmManagerService 系统闹钟的服务 
InputManagerService 管理键盘和触摸输入的服务
BluetoothService 管理蓝牙设备的服务
InputMethodManagerService 提供输入法管理的服务
LockSettingsService 管理锁屏的服务
ClipboardService 系统剪切板的服务
NotificationManager 通知的服务
WallpaperManagerService 桌面背景的服务
UsbService 管理usb设备和连接的服务
这三个方法里面创建了系统里面重要的服务，并把它们纳入SystemServerManager的管理。
SystemServiceManager.startService创建service的实例，然后调用实例的onStart方法。
**所有实例start完毕后，也就是startOtherServices()方法执行最后，开始systemReady流程（mActivityManagerService.systemReady(new Runnable() ）。**
systemReady方法里面执行完WebViewFactory.prepareWebViewInSystemServer();之后执行startSystemUi(context);（启动SystemUIService），然后通过调用WindowManager的onSystemUiStarted方法调用KeyguardService启动锁屏服务。SystemUI启动成功后表示系统的通知栏和导航栏已经初始化成功。
在systemReady(final Runnable goingCallback) 方法中，先调用deliverPreBootCompleted发送开机广播，然后调用startHomeActivityLocked启动Launcher和HomeActivity。
[具体参考](https://www.jianshu.com/p/1adfd446e4fa)
[具体参考](https://blog.csdn.net/cj5785/article/details/78876118)
[具体参考](https://www.jianshu.com/p/4699d50deb99)

### app启动流程
* 点击桌面App图标发起startActivity请求：原Activity的onPause，新Activity的onCreate，新Activity的onStart，新Activity的onResume，原Activity的onStop，原Activity的onSaveInstanceState。
* Activity.startActivity(Intent).startActivity(Intent, Bundle).startActivityForResult(Intent, int, Bundle)==>
Instrumentation.execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)==>
ActivityManagerNative.getDefault() 返回 ActivityManagerProxy 对象==>
（原app的SystemServer客户端）
ActivityManagerProxy.startActivity(...)==>
mRemote.transact(...)==>
ActivityManagerNative.onTransact(int, Parcel, Parcel, int)进行 IPC 调用==>
（原app的SystemServer（客户端身份）==> 第一个zygote进程创建的SystemServer（服务端身份））
ActivityManagerService.startActivity(...).startActivityAsUser(...)==>
ActivityStackSupervisor.startActivityMayWait(...).startActivityLocked(...).startActivityUncheckedLocked(...)==>
ActivityStack.resumeTopActivityLocked(...).resumeTopActivityInnerLocked(...)==>
ActivityStackSupervisor.startSpecificActivityLocked(...).realStartActivityLocked(...)==>
app.thread.scheduleLaunchActivity(...)==>
ApplicationThreadNative。ApplicationThreadProxy#scheduleLaunchActivity(...)==>
mReote.transact(...)==>
ApplicationThreadNative.onTransact(...)进行 IPC 调用==>
（第一个zygote进程创建的SystemServer（客户端身份）==>新app的SystemServer（服务端身份），新app没有启动就会先启动再请求）
（新app的SystemServer服务端，以下认为新app已经启动）
ActivityThread.ActivityThread.ApplicationThread#scheduleLaunchActivity(...)
通过 Handler 发送消息 LAUNCH_ACTIVITY
ActivityThread$H#handleMessage(...).handleLaunchActivity(...).performLaunchActivity(...)==>
Activity.attach(...)==>
Instrumentation.callActivityOnCreate()==>
Activity.performCreate(...).onCreate(...)
[具体参考](https://www.jianshu.com/p/d1b08c184d55)
* 原app的SystemServer（客户端身份）通过binder IPC向第一个zygote进程创建的SystemServer（服务端身份）发送startActivity请求；
* AMS(system_server进程)接收到请求后，判断新app有没有启动，没有启动则通过socket向zygote进程发送创建进程的请求；
* Zygote进程fork出新的子进程，即App进程；
* App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；
* system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；
* App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；
* 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。
* 到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。

### 音视频播放
所有音视频播放都是ui层的绘制，调用的是第三方封装好的视频播放sdk，第三方的底层调用的是FFmpeg解码
所谓的音视频格式，其实就是文件后缀名，文件内容还是编码。
编码有各种协议，FFmpeg负责对这一块进行解码。
VideoActivity（或者MediaActivity）中的VideoView--WeLiveView--UVideoView--
merge.tv.danmaku.ijk.media.player.AndroidMediaPlayer（bilibili开源框架）--使用的是FFmpegApi解码（也是开源框架）
bilibili开源框架ijkmedia使用的是--安卓的android.media.MediaPlayer

### apk优化
* 小图标用svg图片，大图片用webp
https://developer.android.google.cn/studio/write/vector-asset-studio
 defaultConfig {
        vectorDrawables.useSupportLibrary = true
      }
  dependencies {
      compile 'com.android.support:appcompat-v7:23.2.0'
    }
  布局中使用：app:srcCompat="@drawable/ic_pic"
* tint着色器
同一张图片，点击的时候改变颜色，而不是两张图片。
创建一个selector1，里面设置item的drawable
创建一个selector2，里面设置item的color
在使用的imageview中设置android:src="@drawable/selector1',设置android:tint="@color/selector2'。
* 资源打包
defaultConfig {
  resConfigs("zh-rCN","ko")//逗号分隔，添加多个语言包
  }
* so库打包
互联网项目：使用'armeabi', 'armeabi-v7a'  或者问提供商要这两个的合并库。
传统项目（定制化项目）：
有的兼容安卓3.0就用v4。
mips和mips64库windows系统
x86库是32位模拟器
x86_64库主要是64位模拟器
    sourceSets{//将so库打包到apk内
        main{
            jniLibs.srcDirs=['libs']
        }
    }
defaultConfig {
  ndk {//配置so库架构（一般 真机：arm  模拟器：x86）
    abiFilters('armeabi', 'armeabi-v7a')
  }
}
* 移除无效资源
删除之前一定要备份代码，方便版本回归。
lint工具检查 Analyze--Run Inspection by Name--unused resource
* 代码混淆压缩
buildTypes{
  debug{
    // 源代码的压缩
    minifyEnabled true
  }
}
* 启用shrinkResources资源缩减，就不要第五项手动删除资源了。
buildTypes{
  debug{
    // 资源文件的压缩，没有用到的图片会变成占位图（几b的内存）
    shrinkResources true
  }
}
在res文件夹下面新建raw文件夹，再新建keep.xml文件，内容为：
<?xml version="1.0" encoding="utf-8"?>
<resources xmlns:tools="http://schemas.android.com/tools"
  tools:discard="@color/color1"
  tools:keep="@drawable/pic1"
  tools:shrinkMode="stricts"/>
* webp转换插件-----图片变小
* 资源res文件混淆和7ZIP压缩

### Android之系统自带的文字外观设置
“android:textAppearance=“?android:attr/textAppearanceLargeInverse”这里引用的是系统自带的一个外观，？表示系统是否有这种外观，否则使用默认的外观。
可设置的值如下：textAppearanceButton/textAppearanceInverse/textAppearanceLarge/textAppearanceLargeInverse/textAppearanceMedium/
textAppearanceSmallInverse/textAppearanceMediumInverse/textAppearanceSmall/

### descendantFocusability解决焦点问题。
该属性有三种值：
beforeDescendants：viewGroup会优先其子类控件而获得焦点
afterDescendants：viewGroup会当其子控件不需要获得焦点时才获取焦点
blockDescendants：viewGroup会覆盖子类控件而直接获得焦点
* ListView的item有Button时，点击item无响应。
【根布局本身就是一个viewGroup】把item的根布局的属性设置为android：descendantFocusability=“blockDescendants”
* 在ScrollView时，里面包裹的内容超过了屏幕的长度，当进去scrollView直接自动滑动到最底部。
【父控件获得焦点，不把焦点传递给子控件】scrollView下面的ViewGroup中设置android：descendantFocusability为blockDescentants。

### 安卓build的生命周期
从上往下：
* setting.gradle执行gradle.settingsEvaluated {
    println "settings：执行settingsEvaluated..."
}
* setting.gradle执行gradle.projectsLoaded {
    println "settings：执行projectsLoaded..."
}
* setting.gradle执行gradle.beforeProject { proj ->
    println "settings：执行${proj.name} beforeProject"
}
* 外部build.gradle第一行执行
* 外部build.gradle执行task rootTest {
    println "根项目里任务配置---"
    doLast {
        println "执行根项目任务..."
    }
}
* 外部build.gradle的rootTest方法后执行
* setting.gradle执行gradle.afterProject { proj ->
    println "settings：执行${proj.name} afterProject"
}
settings：执行settingsEvaluated...
settings：执行projectsLoaded...
settings：执行test beforeProject
根项目配置开始---
根项目里任务配置---
根项目配置结束---
settings：执行test afterProject
settings：执行app beforeProject
子项目beforeEvaluate回调...
APP子项目配置开始---
APP子项目里任务配置---
APP子项目配置结束---
settings：执行app afterProject
APP子项目afterEvaluate回调...
settings: 执行projectsEvaluated...
构建结束...

### SensorManager安卓传感器
//获取SensorManager实例
sensorManager= (SensorManager) getSystemService(Context.SENSOR_SERVICE);
//获取当前设备支持的传感器列表
List<Sensor> allSensors = sensorManager.getSensorList(Sensor.TYPE_ALL);
* getName()//获取传感器名字
* getVendor()//获取传感器供应商
* getType()//获取传感器种类
Sensor.TYPE_ACCELEROMETER//加速度传感器
Sensor.TYPE_GYROSCOPE//陀螺仪传感器
Sensor.TYPE_LIGHT//光线传感器
Sensor.TYPE_MAGNETIC_FIELD//磁场传感器
Sensor.TYPE_ORIENTATION//方向传感器
Sensor.TYPE_PRESSURE//气压传感器
Sensor.TYPE_PROXIMITY//距离传感器
Sensor.TYPE_TEMPERATURE//温度传感器
* getVersion()//获取传感器版本
* getMaximumRange()//获取最大范围
* getResolution()//获取精度
* getPower()//传感器使用耗电量
* getMinDelay()//最小延时
* getFifoReservedEventCount()
* getFifoMaxEventCount()
* getStringType()

### PowerManager安卓电量管理
尽量避免使用这个类，并且使用完以后一定要及时释放。只要我们拿着这个锁， 那么系统就无法进入休眠状态。
* 添加权限：<!-- 允许应用在手机屏幕关闭后后台进程仍然运行 -->
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.DEVICE_POWER"/>
* 获取 WakeLock 对象：
PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
PowerManager的几个实用方法:
isScreenOn ()判断屏幕是否亮着（不管是暗的dimed还是正常亮度），在API20被弃用，推荐boolean PowerManager::isInteractive ()
goToSleep(long time)time是时间戳，一般是System.currentTimeMillis()+timeDelay。强制系统立刻休眠，需要Manifest中添加权限"android.permission.DEVICE_POWER"。按下电源键锁屏时调用的就是这个方法。
wakeUp(long time)唤醒屏幕。参数含义，所需权限与上同。按下电源键解锁屏幕时调用的就是这个方法。
reboot(String reason)重启手机，reason是要传给linux内核的参数，比如“recovery”重启进recovery模式，“fastboot”重启进fastboot模式。需要权限"android.permission.REBOOT"。
mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, getClass().getName());
* WakeLock的等级：
1.PARTIAL_WAKE_LOCK：保证CPU保持高性能运行，而屏幕和键盘背光（也可能是触摸按键的背光）关闭。一般情况下都会使用这个WakeLock。
2.ACQUIRE_CAUSES_WAKEUP：这个WakeLock除了会使CPU高性能运行外还会导致屏幕亮起，即使屏幕原先处于关闭的状态下。
3.ON_AFTER_RELEASE：如果释放WakeLock的时候屏幕处于亮着的状态，则在释放WakeLock之后让屏幕再保持亮一小会。如果释放WakeLock的时候屏幕本身就没亮，则不会有动作。
mWakeLock.acquire();//获得WakeLock
mWakeLock.release();//释放WakeLock
isHeld()//是否已经获取WakeLock
setReferenceCounted(boolean value)：//是否使用引用计数。类似于垃圾回收策略，只是把垃圾回收改成了WakeLock回收。

### android图片区域点击（图片热区）
com.peopledailychina.activity:id/mAreaImageView
com.hotimg.view.MapAreaView
[具体参考](https://blog.csdn.net/yq135314/article/details/84439921)
[具体参考](https://blog.csdn.net/DT235201314/article/details/78190492)
[具体参考](https://blog.csdn.net/qq_20082063/article/details/76021963)
[具体参考](https://blog.csdn.net/ausboyue/article/details/78267461)
[具体参考](https://blog.csdn.net/qq_28649655/article/details/89286445)
[具体参考](https://blog.csdn.net/DT235201314/article/details/78133932)
* 把要用的图片调整为合适的大小后（重要），导入到Dreamweaver中，在图片上，把需要添加事件的部分建立图片“热区”，然后映射到手机上的相应区域。
for(String key : keys) {
				idenId = mContext.getResources().getIdentifier(key, "array", mContext.getPackageName());
				int[] paths = mContext.getResources().getIntArray(idenId);
				idenId = mContext.getResources().getIdentifier(key + "_code", "array", mContext.getPackageName());
				String[] ptKeys = mContext.getResources().getStringArray(idenId);
				bodyArea = new MapArea(ptKeys, paths);
				mMapArea.put(key, bodyArea);
			}
* 进行不同材质机器的兼容
private float toDip(Context context,float pxValue){
	final float scale = context.getResources().getDisplayMetrics().density;
	return (int) (pxValue * scale + 0.5f);
}
* 判断触摸点是否在热点区域
protected void checkAreas(MotionEvent event) {
        mFocus.clear();
	for(String key : mMapArea.keySet()) {
		mPathRectF.setEmpty();
		Path path = mMapArea.get(key).getPath();
		path.computeBounds(mPathRectF, true);
		if(mPathRectF.contains(event.getX(),event.getY())) {
			mFocus.add(key);
			break;
		}
	}
}

### LruCache的使用，以图片缓存为例
int maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024);
int cacheSize = maxMemory/8;
mMemoryCache = new LruCache<String,Bitmap>(cacheSize){
    @Override
    protected int sizeOf(String key, Bitmap value) {
        return value.getRowBytes()*value.getHeight()/1024;
    }
};
* 设置LruCache缓存的大小，一般为当前进程可用容量的1/8。 
* 重写sizeOf方法，计算出要缓存的每张图片的大小。
**注意：缓存的总容量和每个缓存对象的大小所用单位要一致。**
* 成员变量有：size;//当前cache的大小，maxSize;//cache最大大小，putCount;//put的次数
* createCount;//create的次数，evictionCount;//驱逐剔除的次数，hitCount;//命中的次数，missCount;//未命中次数

### LruCache使用的是LinkedHashMap，LinkedHashMap的理解
* HashMap的两个属性Entry<K,V>  before,after。Entry的构造函数还有一个next指针，用于维护before,after的连接顺序。
* LinkedHashMap在HashMap功能上，增加Entry<K,V>  header(链表的头结点)，跟before,after组成一个双向链表，来实现按插入顺序或访问顺序排序。
* LinkedHashMap多线程不安全
* LinkedHashMap<>(0, 0.75f, true);构造函数的三个参数：初始容量,客座率，默认0.75f, true：基于访问顺序,默认是false，基于插入顺序
* true：基于访问顺序。最近访问的对象会被放到队尾，然后最后输出。
* LruCache正是用了LinkedHashMap的accessOrder=true构造参数实现LRU访问顺序。

### HandlerThread理解
* 使用：
//创建异步HandlerThread
HandlerThread handlerThread = new HandlerThread("downloadImage");
//必须先开启线程
handlerThread.start();
//子线程Handler
Handler childHandler = new Handler(handlerThread.getLooper(),new ChildCallback());
//每个1秒去更新图片
childHandler.sendEmptyMessageDelayed(i,1000*i);     
//该callback运行于子线程
class ChildCallback implements Handler.Callback {
    @Override
    public boolean handleMessage(Message msg) {
        //在子线程中进行网络请求
        Bitmap bitmap=downloadUrlBitmap(url[msg.what]);
        Message msg = mUIHandler.obtainMessage();
        msg.what = 1;
        msg.obj =bitmap;
        //通知主线程去更新UI
        mUIHandler.sendMessage(msg);
        return true;
    }
}
private static class UIHandler extends Handler {
    // 弱引用activity
    private WeakReference<Activity> mActivity;

    public UIHandler(Activity activity) {
        mActivity = new WeakReference<>(activity);
    }

    @Override
    public void handleMessage(Message msg) {
        UIActivity activity = (UIActivity) mActivity.get();
        if (activity == null || activity.isFinishing()) {
            return;
        }
        try {
            switch (msg.what) {
                case 1:
                    Log.d(TAG, "handleMessage");
                    if (msg.obj == null) {
                            return;
                    }
                    imageView.setImageBitmap((Bitmap)msg.obj);
                    break;
                default:
                    break;
            }
        } catch (Exception e) {
            Log.e(TAG, "handleMessage Exception: " + e.toString());
        }
    }
} 
* HandlerThread本质上是一个线程类，它继承了Thread；
* HandlerThread有自己的内部Looper对象，可以进行looper循环；
* 通过获取HandlerThread的looper对象传递给Handler对象，可以在handleMessage方法中执行异步任务。
* 创建HandlerThread后必须先调用HandlerThread.start()方法，Thread会先调用run方法，创建Looper对象。


















