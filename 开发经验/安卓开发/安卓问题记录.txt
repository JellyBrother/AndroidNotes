### 项目初始化报错
* gradle命令版本不对，检查电脑path环境变量配置
* 构建工具版本要跟开发工具里面的gradle的版本一致
* 删除gralde里面的build缓存，刷新依赖，重新构建，还是不行，重启开发工具

### 获取token失败。后台用长token请求成功，用短token失败。
移动端使用短token访问，后台需要解析成长token，后台使用的是第三方jar包，解析失败。

### 图片加、载不一致，pc端和ios端是一样的，安卓原生浏览器不一样，自己的应用又不一样。
后台提供的图片地址是百度上面搜索给到的地址，里面很多乱码。需要对地址进行转码，并对一些字符进行替换处理。

### 主页点击后进详情，返回时显示空白
缓存逻辑处理问题。首先，缓存只存第一屏数据，并且是不为空，有数据的才缓存。页面显示的时候，需要对数据进行判空处理。
需要区分第一次加载，下拉加载，上拉加载，页面恢复的时候加载。

### 附件下载多次查看，提示文件格式错误，文件无法打开
原因是下载的时候加密了，设置为不加密。

### 附件下载多次查看，提示附件不存在
应用启动的时候，删除了文件夹，需要添加例外

### 设置弹框的时候，控件宽高没有根据屏幕大小变化。
获取手机的宽高在初始化进行，切换横竖屏的时候，没有再次赋值。

### handle使用
* handle使用静态类，并且弱引用。
* 发送消息使用十进制，禁用十六进制。
* 消息处理可以try，防止异常。
* default:使用 break; 禁用super.handleMessage(msg);
* 子线程创建handle要调用Looper.prepare()，创建完成后要调用Looper.loop();//开启Looper的循环

### 上下文使用
尽量使用activity，安卓分屏适配要使用activity来startActivity，不能使用context否则会崩溃。

### 不继承base会闪退。
原因是base有主题设置，各个控件有的布局文件有引用这些配置，不集成的话，会找不到。
继承base或者不继承base，自主添加这个主题。

### long类型强转成int类型，会导致结果是负数
先确认到底是不是long类型，不要强转。

### 解决内存溢出：Out Of Memory---OOM
分配的内存不足以放下数据项序列,称为内存溢出。
* 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 
* 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 
* 死循环或递归调用
解决：
- 检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。
- 使用内存查看工具动态查看内存使用情况　
- 代码观察内存变动
Runtime.getRuntime().freeMemory();//可用内存
long use = total - free;//使用了的内存
* 对代码进行走查和分析，找出可能发生内存溢出的位置。
- 检查是否有一次获得全部数据的查询
- 检查代码中是否有死循环或递归调用
- 检查是否有大循环重复产生新对象实体
- 检查List、MAP等集合对象是否有使用完后，未清除的问题

### 解决内存泄露：Memory Leak
内存没有释放或者释放不完全，导致内存持续增加。到最后内存溢出。
* 单例导致对象不能回收
* 静态变量赋值大
* Handler(当非静态内部类对象的生命周期比外部类对象的生命周期长),消息在队列中未处理或者正在处理。
* 未取消注册或回调导致内存泄露
* 集合中的对象未清理造成内存泄露
* WebView造成内存泄露
* 计时或循环任务一直运行，没有取消
* listview没有复用，一直创建新对象
* 文件读写及时关闭
* Handler静态或者在页面onDestory的时候mHandler.removeMessages();都可以解决Handler内存溢出问题。
解决:
* 对异常进行监控、日志打印、日志上传到服务器，进行持续跟踪改进。
* 使用LeakCanary和Profiler工具进行分析。
* 在基类的onDestory方法中遍历view，进行资源清理，移除handler消息。各个页面销毁掉时候，要销毁各个监听。
* 再application中监控到内存低的时候，对资源进行清理。
* 图片加载使用565而不是888格式，宽高根据控件宽高展示，而不是屏幕宽高。
* 单例模式尽量使用application上下文。
* Handler使用静态和弱引用，default的时候直接break掉。
* 内部类持有外部类引用的时候，将内部类静态化。
* 大数据传递的时候intent限制了大小，建议使用eventbus或者静态变量。
* 代码观察内存变动
Runtime.getRuntime().freeMemory();//可用内存
long use = total - free;//使用了的内存

### 应用程序无响应（ANR）
https://blog.csdn.net/qq_20798591/article/details/104259833?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-104259833-blog-117619787.235%5Ev36%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-104259833-blog-117619787.235%5Ev36%5Epc_relevant_default_base&utm_relevant_index=9
* anr文件在/data/anr/文件夹下面，root获取。
* 在events_log文件里面找到进程id： am_anr|am_low_memory
* dropbox的anr日志看main线程打印
* 在main_log文件里面找到报ANR的时间点：Application is not responding:  和 ANR in
* 在anr_文件里面分析trace信息，根据进程id找主线程的堆栈，运气好，可以直接找到报错位置。
* 在报错位置点前5秒日志里面找。
* 关键字：
Application is not responding:  
ANR in
am_anr 
am_proc_start 
am_kill 
InputReader 
InputDispatcher 
InputEventReceiver: dispatchInputEvent  
ufs_io  去kernel_log中看io
watchdog  去kernel_log中看io,看是否有等待或者被锁
RMS-Reclaim  去main看内存
RMS-policy：MemTotal  去main看内存
87% 1172/system_server: 55% user + 31% kernel / faults: 26122 minor  //这里如果90%以上就是CPU太高
  50% 138/kswapd0: 0% user + 50% kernel //kswapd的CPU占用高，Kernel层内存交换进程，通常值低于25%。
69% TOTAL: 12% user + 32% kernel + 14% iowait + 3.6% irq + 5.9% softirq //这里是60%以上CPU太高，io操作cpu占用很高，通常值低于10%。
trace记录的anr和sys记录的anr时间可能相差很大，需要核对里面的进程id。
主线程state=R说明系统cpu可以分配，Runnable表示正在运行，没有堵塞。state为s，cpu不给资源。
大于10，系统负载重。
06-25 01:59:13.400  9635  9653 W Monkey  : Load: 38.8 / 33.99 / 32.35
* 看events_log的am_anr|am_low_memory，了解当前是否低内存，是否多个应用anr。找到自己应用anr的地方，看当前界面的生命周期。
* 看main_log的ANR in，当前cpu的使用状态，是否占用很高，是否负载很重，anr发生的时长。
* 看dropbox的trace文件，cpu使用情况，io情况，cpu运行状态，主线程执行情况，是否有锁占用，跨进程通信，是否有具体代码行。
kswapd耗时长, CPU占用高,导致ANR  
   2). 当前系统严重过载，（Load:40.18 一分钟内40.18个进程等待 / 41.16 五分钟 / 43.28 十五分钟 单核过载不能超过1，八核手机不能超过8）//AnrManager: Load: 40.18 / 41.16 / 43.28
   3). kswapd cpu占用过高：kernel层一直占用，该进程一般是内存低或者内存碎片过多时进行内存页面交换，CPU高于39%属于不正常，Kernel层内存交换进程，通常值低于25%
cpu饥饿导致系统卡顿，当前系统繁忙，为了优先保证系统进程执行，暂停了com.tencent.mt应用14.262ms。
Line 101085: 07-01 20:25:15.307791 10171 10183 W com.tencent.mt: Suspending all threads took: 14.262mskernel 
log显示kswapd交换频繁:触发低内存杀死进程
Line 93072: <6>[80822.561532]  (6)[127:kswapd0]lowmemorykiller: ^RSC kswapd0 127 cost 1309 us lowmem_scan r 26077
* cup使用率：(totalCPUTime – idleCPUTime) / totalCPUTime
总cpu使用率超过60%，单核cpu使用超过90%，意味着cpu繁忙
* 获取手机cpu个数：cat /sys/devices/system/cpu/possible

### 广播anr：
无序广播不会anr。
默认APP在发送广播时发送的是background broadcast。如果APP想要发送foreground broadcast，需要在准备发送的Intent中增加一个Flag，代码如下： intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
前台广播：当BroadcastReceiver在10秒内没有处理完该broadcast时，会触发ANR。Timeout的时间定义在：ActivityManagerService.BROADCAST_FG_TIMEOUT=10*1000;
后台广播：当BroadcastReceiver在60秒内没有处理完该broadcast时，会触发ANR。Timeout的时间定义在：ActivityManagerService. BROADCAST_BG_TIMEOUT =60*1000；
AMS在发送mOrderedBroadcasts队列中的broadcast给BroadcastReceiver时，会先判断该BroadcastReceiver所在的APP进程是否已存在，如果不存在，就会先创建该APP进程。并且，创建该APP进程所消耗的时间也算在Timeout时间之内。
(1) 导致BroadcastReceiver Timeout类型的ANR有三种情况：
*创建APP进程耗时太久，超过了Timeout时间。这种情况不多见。
*APP进程的Main Thread处理的事情太多，没有时间执行BroadcastReceiver. onReceive()方法。
*APP进程的Main Thread执行BroadcastReceiver. onReceive()过长。这种情况最多见。
(2)当出现BroadcastReceiver Timeout类型的ANR时，会打印以下信息：
BroadcastQueue: Timeout of broadcast BroadcastRecord{15f4f607 u0 com.tf.broadcastanrdemo} - receiver=android.os.BinderProxy@12d8940f, started 10000ms ago
BroadcastQueue: Receiver during timeout: BroadcastFilter{273fd6a5 u0 ReceiverList{15edcc9c 24578 com.example.testBroadcast.bctwo/10129/u0 remote:12d8940f}}
其中，蓝色和红色部分log会被具体的broadcast替代。从这两句log我们可以看出：APP进程(packageName= com.tf.broadcastanrdemo)在处理Action= com.example.testbroadcast.bctwo的broadcast时，发生了ANR。
注意：只有当发生ANR的APP进程中存在前台显示的Activity时，或者用户在’开发者选项’中将’显示所有“应用无响应”(ANR)’的选项选中，AMS才会弹出ANR对话框。否则AMS会直接杀掉该APP进程。
PS: 对于接收同一个广播，在相同优先级的情况下，动态注册优先级别高于静态注册。在动态注册中，最早动态注册优先级别最高；在静态注册中，最早安装的程序，静态注册优先级别最高

### ANR抓取trace命令
有时候缺少anr进程trace, 必现场景可以使用以下命令抓取trace信息：
一、本地抓取trace命令： $chmod 777 /data/anr
$rm /data/anr/traces.txt
$ps //anr进程pid
$kill -3 PID //anr进程pid
$adb pull /data/anr/traces.txt
PS: 若上述命令无法生成traces.txt, 需：
    * 先进/data目录
    * 然后chmod 777 /anr
二、本地查看CPU使用率命令：
  方法1：adb shell top -n 1 -d 0.5 | grep proc_ id
            （adb shell top -m 10 -s cpu 该命令会显示CPU使用率最高的前十个应用）
  方法2：adb shell dumpsys cpuinfo | grep proc_pid
  方法3：开发者选项中-》显示CPU使用情况

### 页面性能优化：
* 复杂布局：减少布局嵌套
* 过度绘制：可以开启手机过度绘制调试，找到该页面，减少背景色。背景色尽量放子view中
* 复杂操作：代码优化（减少对象创建，减少循环），放子线程执行复杂操作，主线程刷新ui。
* 提高显示速度,使用ViewStub：当加载的时候才会占用。

### 代码规范
* 程序结构清晰，简单易懂，单个函数的程序行数不得超过100行。
* 不要随意定义全局变量，尽量使用局部变量。
* 可读性第一，效率第二（命名规范，要有注释）
* 程序首先是正确，其次是优美
* 所以变量在调用前必须被初始化
* 对所有的用户输入，必须进行合法检查
* 慎重使用强转（long转int类型）
* 单元测试，自测
* 重复使用的完成相对独立功能的算法或代码应抽象为公共控件或类
* 公共控件或类应考虑面向对象思想，减少外界联系，考虑独立性或封装性
* 尽量在类中使用final，private修饰符
* 保证过期对象及时回收
* 尽量用的时候初始化或者加载，避免提前加载而用不到，导致内存消耗
* 重写equals和hashcode方法（特别是map集合）
* 采用对象池技术，提高对象的利用效率
* 尽量避免使用内在的Get,Set方法（应该直接调用）
* 判空
* 异常捕获

### 富文本编辑器方案有
* 原生使用span进行处理，但是耗性能，而且兼容性不好。
* 原生使用adapter，先定义好数据模型，根据用户输入内容来刷新列表数据，很难处理点击事件和焦点。
* 使用H5的富文本编辑器，也有兼容性问题需要处理。

### 富文本编辑器总结
* 写博客软键盘弹出监听和横竖屏切换使用OnGlobalLayoutListener
* 软键盘弹出会遮挡输入框，需要在弹出的时候监听布局高度，手动设置布局高度，并且防止多次调用。

###  H5富文本编辑器有图片内容的时候，有些输入法会联想出OBJ字符，替换前后的输入内容
解决方法：
创建IInputConnectionWrapper监听软键盘输入，及时替换OBJ。
光标后移，并且图片宽度全屏，这样输入的时候就不会在图片后面联想出OBJ了，
最终获取编辑器内容的时候需要替换OBJ，并且其他的输入框也要替换，因为用户可以复制编辑器内容粘贴到输入框。
H5富文本编辑器点击的时候，弹出软键盘，需要让编辑器滑动到点击位置。当点击在底部的时候，H5需要延时200才能滑动到底部。

### 输入法连接定位跟踪
IInputConnectionWrapper发送消息InputConnectionWrapper处理
点击联想输入
点击键盘按键输入
beginBatchEdit-setComposingText-endBatchEdit-getTextBeforeCursor-getTextAfterCursor
编辑器输入文字，有时候删除不了，因为不同的机器和不同的输入法对删除操作兼容不好，
需要监听IInputConnectionWrapper的 deleteSurroundingText 和 deleteSurroundingTextInCodePoints方法 来自行处理删除事件

### 控件销毁的方法onDetachedFromWindow里面不要随意进行销毁动作，会有异常
activity的生命是大于控件的，控件销毁了，activity不一定销毁，所以最好是放activity里面执行销毁操作。

### 写博客页面点击拍照返回写博客页面，会异常。
原因是拍照页面定义的风格是全屏，跟写博客页面不一样，导致重新设置页面的时候，高度设置为了0
写博客页面监听布局改变的时候，会出现多次。
拍照页面隐藏的时候onPause，写博客页面恢复onResume，布局监听生效。
拍照页面销毁的时候onDestroy，写博客页面布局监听生效。
需要在监听生效里面，处理高度为0的情况，为0的时候，不重新布局。

### IntentService
是Service的子类，继承IntentService的类至少要实现两个函数：构造函数和onHandleIntent()函数
* 它创建了一个独立的工作线程来处理所有的通过onStartCommand()传递给服务的intents。
* 创建了一个工作队列，来逐个发送intent给onHandleIntent()。
* 不需要主动调用stopSelft()来结束服务。因为，在所有的intent被处理完后，系统会自动关闭服务。
* 默认实现的onBind()返回null
* 默认实现的onStartCommand()的目的是将intent插入到工作队列中

### handleThrow 异常处理或者异常捕获
整个应用自定义异常捕获：
实现异常捕获接口：Thread.UncaughtExceptionHandler
设置当前异常捕获对象：Thread.setDefaultUncaughtExceptionHandler(this);
处理异常信息：uncaughtException
常见异常有：空指针、数据越界、内存泄漏、资源id找不到

### Android中实现进程通信的方式
IPC定义：IPC是intent-Process Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。
通信的方式有：AIDL、Messager、ContentProvider、Socket、Bundle
AIDL：底层实现是Binder。我们只需要写好 aidl 接口文件，编译时系统会帮我们生成 Binder 接口。
AIDL 支持的数据类型：①Java 的基本数据类型②List 和 Map；③其他 AIDL 生成的接口；④实现 Parcelable 的实体
https://www.cnblogs.com/bugzone/p/aidl.html

Messager：底层实现是AIDL。我们可以在客户端发送一个Message给服务端，在服务端的handler中会接收到客户端的消息，然后进行对应的处理，处理完成后，再将结果等数据封装成Message，发送给客户端，客户端的handler中会接收到处理的结果。
支持回调的方式，也就是服务端处理完成长任务可以和客户端交互
不需要编写aidl文件
https://www.cnblogs.com/qlky/p/6731063.html

ContentProvider：底层实现是Binder。是Android中提供的专门用于不同应用间进行数据共享的方式，从这一点看，它天生就是和进程间通信。
https://blog.csdn.net/shaochen2015821426/article/details/79748487

Socket它分为流式套接字和用户数据套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议。TCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；而UDP是无连接的，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。在性能上，UDP具有更好的效率，其缺点是不保证数据一定能够正确传输，尤其是在网络繁重的时候。
https://blog.csdn.net/qq_38998213/article/details/89900211

 Bundle: 主要用于传递数据；它保存的数据，是以key-value(键值对)的形式存在的。
                Bundle bundle = new Bundle();
                // 把Persion数据放入到bundle中  
                bundle.putSerializable("persion",persion);
                bundle.putParcelable("persion",persion);
                Intent intent1=new Intent(MainActivity.this,Main2Activity.class);
                intent1.putExtras(bundle);
                startActivity(intent1);
Bundle bundle=intent.getExtras();
 Persion persion= (Persion) bundle.getSerializable("persion");
 Persion persion= (Persion) bundle.getSerializableExtra("persion");

### Webview的加载优化
* js文件放本地
* js网络请求采用原生桥接
* Webview提前创建好，使用的时候就从集合中去取，然后再addview到父布局。
public static List<Webview> webviewList = new ArrayList<>();
    private Webview getWebview() {
        if (webviewList.size() > 0) {
            for (Webview webview : webviewList) {
                if (webview.getParent() == null) {
                    //webview初始化
                    webview.init();
                    return webview;
                }
            }
        }
        Webview webview = new Webview(context);
        webview.init();
        webviewList.add(webview);
        return webview;
    }
* 原生提前请求服务数据，然后调用桥接，把数据给h5.

### React Native白屏优化
* 预加载,将ReactRootView提前创建，保存到静态集合中，需要的时候，通过从集合中去拿。
//RN的白屏问题就是出现在这里，两个比较耗时的函数分别为getReactNativeHost().getReactInstanceManager()和mReactRootView.startReactApplication，
  //预先缓存就是针对这里的，把这一步的操作，提前完成，然后用的时候，直接从内存开始加载
  protected void loadApp(String appKey) {
    if (mReactRootView != null) {
      throw new IllegalStateException("Cannot loadApp while app is already running.");
    }
    mReactRootView = createRootView();
    mReactRootView.startReactApplication(
      getReactNativeHost().getReactInstanceManager(),
      appKey,
      getLaunchOptions());
    getPlainActivity().setContentView(mReactRootView);
  }
* 设置默认背景，加载完成后再把背景去掉

### 有些古怪闪退，需要异常捕获
FragmentStatePagerAdapter类中   
    @Override
    public void restoreState(Parcelable state, ClassLoader loader) {
        try { //解决中英文切换后，返回主页面，闪退问题
            super.restoreState(state, loader);
        } catch (Exception e) {
            //do nothing
        }
    }

      try {
            Class<?> clz = item.getClass();
            Method m = clz.getMethod(GETPICKERVIEWTEXT);
            contentText = m.invoke(item, new Object[0]).toString();
        } catch (Exception e) {
        }

### 现在手机拍照出来的图片随便就大于20M了，图片上传很容易出问题。
* 获取图片宽高和存储大小，手机端提示用户不能上传。
* 后台放宽图片大小限制。
* 对图片宽高和质量进行等比压缩。压缩后的图片还是太大，再提示用户。
* 图片加载使用565而不是888格式，宽高根据控件宽高展示，而不是屏幕宽高。

### 图片在内存中的占用的空间大小
如100x100的png图片
分辨率为100x100、像素模式为ARGB(支持透明度，A就是Alpha透明度)，就是一个像素需要使用四个基色表示。
像素位数：通常为8位 0-255
图片所占内存大小则是：100x100x4x8/8=40000Byte 不到40KB
大致的计算方式就是上面所讲的。所以在使用图片的时候尤其是图片分辨率比较大的时候就要注意内存的使用情况，尽可能的使用多少图片就用多少，用不到的就是释放掉；
还有特别注意的就是：在使用画布画图的时候生成的画布不要太大，大小分辨率够用即可如果太大，有可能光一个画布就直接把内存给占完了。加入我们生成一个10240x10240分辨率的画布所占内存就是400MB,所以对画布的使用一定要慎重。

### listview的双向联动
* 自定义listview
* 建立全局变量的listview2并让外部设置
* 在ontouchevent方法中调用listview2的ontouchevent方法

### synchronized锁对象
静态方法的锁对象是静态方法所在的类，非静态方法的锁对象是创建调用该方法的new对象。

### 快速识别h5页面
* 加载速度，h5会慢一点 
* 看log日志打印，查看chrom的信息 
* 在手机设置页面打开显示布局边界，h5页面是一整个布局

### aidl.exe'' finished with non-zero exit value 1
buildToolsVersion为29.0.0的时候报错，改成28.0.0。
* android studio编译含有AIDL文件项目里报此错误，是因为项目中的AIDL文件中有引用非JAVA基本数据类型的类，（此类的可能是用到你的方法形参类形）
* 解决方法： 只需要调用此类的形参类型前加 in    或是  out 即可，
如  void getError( in/out Context  context);

### apply from:"${android.sdkDirectory}/xx-ext/Util.gradle" 找不到
因为是系统开发，所以有底层的sdk修改，需要在sdk导入相关的文件夹

#### DevicePropertyUtil报错，找不到包android.telephony.FtTelephony和android.util.FtDeviceInfo
sdk缺失文件

### Could not find tools.jar. Please check that C:\Program Files\Java\jre1.8.0_144 contains a valid JDK installation.
查看jdk有没有tools.jar，没有就需要重新安装jdk。

### 手机连接不上云端
* 安装完成后，重启本地机和云端
* 点击云端设备打钩
* 打开手机的开发者模式进行手机连接，注意数据线和手机的插口稳定。
* 安装PC端手机助手，等待电脑给手机端安装手机助手。
* adb devices查看连接状态
* 开启开发者模式：*#*#7777#*#*
* 开启USB调试端口：*#558# -> 验证测试 -> 开发调试 -> 勾选“调试端口”

### 很多文件提示找不到包
需要配置以下环境
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
 ext {
    compileSdkVersion = "android-28"
    minSdkVersion = 24
    targetSdkVersion = 26
    versionCode = 51200
    versionName = "5.3.2.0"
}
dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
}

### 在xxUtil.gradle文件的1031行报错：the LinkApplicationAndroidResourcesTask dons't genarate the HideRes.xml,please contact *** team!
* sdk不对
* 将gradle版本改成3.1.2
distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
 dependencies {
        classpath 'com.android.tools.build:gradle:3.1.2'
    }

### git拉取代码的时候报错：Permission denied (publickey)
* git配置账号
git config --global user.name **osc（gerrit网站，路径Settings的名字）
git config --global user. **osc@*.com（gerrit网站，路径Settings的邮箱）
* 生成ssh key，并配置到gerrit（如果本地已经有ssh文件，就会生成不了）
a 使用ssh-keygen -t rsa -C "**osc@*.com"命令生成ssh key（邮箱后缀为@*.com）；
b 复制public key文件内容，public key路径如下：C:\Users\你的用户名\.ssh\id_rsa.pub；
c 将复制的public key粘贴到gerrit网站，路径Settings → SSH Public Keys → Add key；

### 报错：\src\main\res\drawable-440dpi: Error: Invalid resource directory name
* 删除drawable-440dpi
* SDk不对

### OEM切换报错端口找不到解决：
* 打开设备管理器，找到端口，核对Diagnostics(COM4)和NMEA 9025(COM6)
* 不对的话：右键属性-端口设置-高级-COM端口号改一下。
* 删掉无效的设备驱动：点击查看-显示隐藏的设备
* 点击扩大镜查找一下
* 联系系统管理员，进行远程的硬件端口核对
* 卸载驱动。

### git push代码的时候，提示：You are not allowed to perform this operation.
需要在android studio添加一个gerrit的插件，用这个插件提交才行。

### 代码冲突解决
* 产生原因：我提交代码到gerrit去审核，审核人觉得有问题，提出修改建议。按照修改建议修改完成后，拉取代码，发现有人提交代码，并且跟我有冲突。
* git add  添加我需要提交的内容
* git commit –-amend –no-edit  对上一次的提交进行修改，并且添加提交说明
* git push origin HEAD:  提交代码到审核分支
* 以上三个是没有冲突的情况下进行操作。当然此时，不拉取代码，就不会产生冲突。
* :q!  让前面的命令执行完毕，正常退出。不能直接关闭，不然上一个命令不能执行完毕。
* git merge --abort  将会抛弃合并过程并且尝试重建合并前的状态（危险操作）
* :q!  让前面的命令执行完毕，正常退出。不能直接关闭，不然上一个命令不能执行完毕。
* git show  显示各种类型的对象
* git remote update  管理一组跟踪的存储库。
* git rebase  在另一个分支基础之上重新应用，用于把一个分支的修改合并到当前分支。
* 这个时候会报红，显示冲突的文件。自己解决完冲突后继续，有可能自己改动的代码也回滚不见了，需要注意代码备份。
* git rebase --continue  
* git push origin HEAD:refs/changes/
* 在原有基础上进行修改用changes：git push origin HEAD:refs/changes/*
* 代码提交到gerrit后，修改了内容，拉取最新代码，不会有冲突的流程：
* git status 查看状态 git add 添加修改 git commit -–amend 在原有修改上再次修改  git pull 拉取最新代码，
git rebase 将当前的修改线放到顶部 git push origin HEAD:refs/changes/* 提交修改，如果有冲突解决冲突，再git commit -–amend，再提交。
* 提交的时候没有git commit -–amend，而是git pull了，有冲突，解决流程：
* git reflog 查看本地git所有提交记录，找到需要gerrit的提交记录后git reset回到那一笔记录，然后正常提交。

### 安卓9.0，webview加载闪退
* app加固策略问题，app加固的so文件跟浏览器so文件冲突。
* 升级app，更新加固策略。
* 升级系统，webview进行修复。

### 设置了点击效果的backgroud，可是点击没反应
viewgroup里面的子控件抢占焦点，或者设置了点击事件。

### 小程序的名称没有显示，显示的是号码
* 先卸载程序adb uninstall **
* 卸载已安装sso debug apk
* 核对是否push的sdk：adb shell ls -l system/priv-app/RcsSDK
* 拉最新代码运行安装应用
* 开启融合通讯功能
* 手动新建会话，输入号码**，给这个号码发一条文本消息（内容随意）.退出会话，再进去，继续发消息，应该就会收到推送的内容。
* 核对输入号码是否有误。

### 使用路径的方式访问被废弃了，用file访问媒体资源
ParcelFileDescriptor的getFile方法

### 代码提示@SuppressLint("NewApi")
原因是有些api不适应低版本，如果在类的前面加这个标签，会导致低版本不兼容，而且不容易发现。
解决方法：1、该类继承v7包兼容类。2、对类里面的方法进行版本兼容处理。

### 资源泄露：Resource leak
TypedArray使用完没有调用：typedArray.recycle();
Cursor查询完毕后调用：cursor.close();
    private static Uri getImageContentUri(Context context, String filePath) {
        Uri uri = null;
        Cursor cursor = null;
        try {
            cursor = context.getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                    new String[]{MediaStore.Images.Media._ID}, MediaStore.Images.Media.DATA + "=? ",
                    new String[]{filePath}, null);
            if (cursor != null) {
                if (cursor.moveToFirst()) {
                    int id = cursor.getInt(cursor.getColumnIndex(MediaStore.MediaColumns._ID));
                    Uri baseUri = Uri.parse("content://media/external/images/media");
                    uri = Uri.withAppendedPath(baseUri, "" + id);
                }
            }
            if (uri == null) {
                ContentValues values = new ContentValues();
                values.put(MediaStore.Images.Media.DATA, filePath);
                uri = context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);
            }
        } catch (Exception e) {
            LogUtils.e(TAG, "error on getImageContentUri cursor: ", e);
            <!-- LogUtils.e(TAG, new Throwable(), "Exception"); -->
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return uri;
    }

### The content of the adapter has changed but ListView did not receive a notification
Exception解读：Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。肯定是Adapter数据动态更新的问题。
* adapter主线程创建后及时设置到listview中，并且跟刷新时候的adapter保持同一个。
* adapter里面的数据操作和刷新要在主线程操作
* 每次数据改变后，都要及时刷新。 

### Thread has finished execution
另外报错：Only the original thread that created a view hierarchy can touch its views.
* 子线程更新ui，需要使用Handler，仔细核对方法：是sendMessage，而不是handleMessage。
* try---catch异常，打印异常日志查看
* 打印线程name，跟踪线程情况，Thread.currentThread().getName()

### R8 Error：Execution failed for task ‘:app:transformClassesWithMultidexlistForAlphaDebug
* 这是AndroidX迁移的时候遇到的问题
* gradle.properties配置了也没用
android.useAndroidX=true //当前项目启用 androidx
android.enableJetifier=true //将项目依赖和第三方依赖包也迁移到androidx
proguard.flags配置了也没用
-keep class pub.devrel.easypermissions.** { *; }
* 解决思路：gradlew build --stacktrace  //打印详细的报错日志
* 意思是类重复或者jar包冲突，完全相同的文件目录下面的文件夹，里面有同样命名和后缀的文件。
* 找到报错的文件，搜索发现有好几个一样的文件，在libs里面配置重复的jar包了。删除重复的jar包就行。
* 也有代码自动生成类产生类重复的问题。

### 静态注册Intent.ACTION_DATE_CHANGED的广播接收器，应用会在经过0点时，被拉起。
因为每次过0点，这个广播都会发送。

### JobScheduler.schedule(JobInfo);
调用后，相应的JobService中onStartJob会被立即调用一次，而不是等到周期到达.

### SQLiteCantOpenDatabaseException
[参考](https://blog.csdn.net/lyyuan01/article/details/72628081)
原因：sqlite在Android系统上的一个bug，在需要建立索引的sql语句频繁执行时，会发生这个异常。
解决方法：第一次建立数据库连接时设置临时文件目录。
private static boolean sIsTmpDirSet = false;
@Override
public SQLiteDatabase getReadableDatabase() {
    if (!sIsTmpDirSet) {
        File cacheFile = context.getCacheDir();
        String tmpDirPath = cacheFile.getPath() + "/databases/tmp";
        File file = new File(tmpDirPath);
        if (!file.exists()) {
            file.mkdirs();
        }
        String sql = "PRAGMA temp_store_directory = '" + tmpDirPath + "'";
        try {
            super.getReadableDatabase().execSQL(sql);
        } catch (Throwable e) {
            // ignore
        }
        sIsTmpDirSet = true;
    }
    return super.getReadableDatabase();
}

### 碰到偶发流程错误的问题处理。
* 根据对应问题的版本去拉代码进行修改，用的问题发生在老版本，而最新版本已经修复了。
* 在关键节点打上日志（判断、页面展示的数据、关键集合、关键变量），不能复现的时候，也能够跟进日志进行定位。
* 流程问题不会有异常，一般是某个操作（特定操作）所得到的结果跟预期不符合，而且不能复现。
* 首先要确认预期是什么样的结果，得到不符合的地方。
* 没有日志的情况下：自己走一遍流程，确认是否属实。然后debug跟进整个流程，判断会出现的节点。
* 有日志的情况下，优先根据日志进行定位。
* 解决该问题的时候，要特别注意关键变量，关键集合，方法嵌套。
* 关键变量控制的逻辑，以及该变量触发和修改的位置。
* 集合是否为空，集合是否重置。
* 当有方法嵌套的时候，需要找到最后一个方法，去确认嵌套逻辑后，再进行修改。

### 在页面初始化的时候获取控件宽高，然后进行尺寸设置的时候，控件不显示。
页面初始化的时候，获取到的宽高为0，当拿到结果进行设置的时候，往往小于预测值。导致控件显示有问题。
* 在重写控件的onMeasure方法，然后调用getMeasuredWidth获取宽高。这里获取的宽高跟真实宽高不一定相同。
int w = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
int h = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED);
view.measure(w, h);
view.getMeasuredWidth(); // 获取宽度
view.getMeasuredHeight(); // 获取高度
* view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

        @Override
        public void onGlobalLayout() {
            view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
            view.getWidth(); // 获取宽度
        }
    });
}

### 从其他应用写邮件，我们应用没有登录，先闪现跳转写邮件页面，再跳转邮件登录页面
修改原因：1、首次进入界面，显示引导，然后延时100毫秒弹出软键盘，没弹之前，点击了附件，就出现这种情况。
2、闪现编辑界面流程为：点击操作-邮件的发邮件页面-邮件的登录页面-点击返回-销毁登录页面-销毁发邮件页面。
解决方法：1、判断是否弹出添加附件的框，有弹出，就不延时弹出软键盘。
2、在发邮件界面点击返回的地方进行登录页面和发邮件页面的销毁操作。
3、去掉写邮件页面主题（之前设为透明背景。后面发现不能设置主题，因为没有主题和没有setContentView的时候，界面是空的，而有主题和没有setContentView的时候界面是白色的）
4、将setContentView放到判断是否有账号登录之后。
5、将页面控件操作放到控件初始化完成之后。
6、在页面销毁的地方的控件判空。

### 为什么在activity的onCreate里面可以子线程更新UI？
首先子线程确实不能更新UI，因为会报错：android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 
这个异常是从android.view.ViewRootImpl的checkThread方法抛出的。
ViewRootImpl是ViewRoot的实现类。在访问UI的时候，ViewRoot会去检查当前是哪个线程访问的UI，如果不是主线程，那就会抛出上面异常.
而执行onCreate方法的那个时候ViewRootImpl还没创建，无法去检查当前线程。
ViewRootImpl创建，是在onResume里面调用performResumeActivity方法调用WindowManager的addView方法，而WindowManager的实现类是WindowManagerImpl。
WindowManagerImpl的addView方法里面WindowManagerGlobal的addView方法创建ViewRootImpl。

### 1、未登录-点击桌面进入登录界面（任务栈1）。2、第三方应用-进入应用（任务栈2）-登录完成-写界面-点击返回（杀掉任务栈2）3、点击系统多任务按钮-切换到的是应用登录界面（任务栈1）
修改原因：同一个进程有两个登陆界面，点击桌面图标创建了栈1，从第三方进来创建栈2，退出时销毁的是栈2内部的对象，切换到登录界面的是栈1。
解决方法：1、清单文件设置singleInstance都不管用。2、使用自定义的工具进行activity的管理。3、在栈2创建对象的时候销毁栈1的对象。
* 查看当前的堆栈信息adb shell dumpsys activity activities > 1
[参考](https://www.cnblogs.com/z964166725/p/8729208.html)
[参考](https://blog.csdn.net/oneil2016/article/details/80950386)

### 未登录情况，多任务切换到后台查看，界面显示黑色
修改原因：1、登录界面点击系统的多任务按钮，应用显示黑屏。2、登录界面开启防截屏。3、有的应用开启防截屏，显示是黑色，有的显示是白色。4、应用使用了Light.NoTitleBa主题
解决方法：1、防截屏不能去掉，涉及用户隐私。2、继承的全局主题不能去掉。3、添加colorBackground属性为白色。<item name="android:colorBackground">@color/panel_background</item>

### 点击输入框，输入文字，回车。当输入框跟软键盘平齐的时候，软键盘隐藏。点击最后一个邮箱输入框输入时。光标当前输入框，但是输入内容时，是在上一个输入框显示。
修改原因：输入回车的时候，软键盘隐藏。再次点击输入框的时候，光标当前输入框，但是输入内容时，是在上一个输入框显示。焦点混乱了。
解决方法：当软键盘隐藏的时候，清除输入框焦点和View.FOCUS_DOWN标记。
[参考](https://blog.csdn.net/i_love_program__19/article/details/80135946)
[参考](https://blog.csdn.net/u010041075/article/details/65445043)
[参考](https://www.jianshu.com/p/053ea7cd27b3)
[参考](https://blog.csdn.net/mingtiannihao0522/article/details/79224189)

### 页面启动闪屏
主要是两个属性：
<item name="android:windowIsTranslucent">true</item>// 是否使用半透明
<item name="android:windowDisablePreview">false</item>// 是否不使用预览
[参考](https://blog.csdn.net/wangjiang_qianmo/article/details/51736418)
[参考](https://my.oschina.net/tedyin/blog/178376)
WindowManager和SurfaceInsetPatch
starting窗口属于 com.example.helloworld/.MainActivity ，可加快启动速度：在主窗口未绘制完成前即显示，正常在主窗口绘制完成后移除。
当前 在启动 MainActivity 后很快启动另一全屏窗口 HelloWorldActivity ，且HelloWorldActivity 没有 starting窗口，导致 starting窗口被移除，而此时因已开始窗口切换，Launcher 已处于不可见状态，闪黑。
解决方法：
A界面使用预览属性，如果A界面展示小于200毫秒，马上跳转B界面，那B界面也要开启预览属性。同理B界面展示小于200毫秒，跳转到其他界面也需要开启预览属性。

### 减少对系统广播资源的占用。
* BOOT_COMPLETED广播接收2次。
全局搜索该广播在清单文件静态注册两次，现在改为一次。动态没有注册。
* DEVICE_STORAGE_OK广播接收2次。
全局搜索，该广播没有在清单文件静态注册。有在Application初始化的时候动态注册。而我们有2个进程，因而会注册两次，将其放到主进程注册。
[参考](https://blog.csdn.net/DKBDKBDKB/article/details/79964475?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)
输入adb shell am 或 adb shell pm查看参数含义.
查看Android系统广播发送记录
dumpsys |grep BroadcastRecord
adb shell dumpsys > sdcard/DEVICE_STORAGE_OK.txt
adb pull /sdcard/DEVICE_STORAGE_OK.txt D:\
am命令发送广播：
am broadcast -a android.intent.action.BOOT_COMPLETED
am broadcast -a android.intent.action.DEVICE_STORAGE_OK // 发送低内存广播再发送内存正常广播系统才生效。
am broadcast -a android.intent.action.ACTION_DEVICE_STORAGE_LOW
通过命令行执行adb shell am broadcast发送广播通知。
adb shell am broadcast 后面的参数有：
[-a <ACTION>]
[-d <DATA_URI>]
[-t <MIME_TYPE>]
[-c <CATEGORY> [-c <CATEGORY>] ...]
[-e|--es <EXTRA_KEY> <EXTRA_STRING_VALUE> ...]
[--ez <EXTRA_KEY> <EXTRA_BOOLEAN_VALUE> ...]
[-e|--ei <EXTRA_KEY> <EXTRA_INT_VALUE> ...]
[-n <COMPONENT>]
[-f <FLAGS>] [<URI>]

### webview打开谷歌网站登陆，提示无法登陆，此浏览器或应用可能不安全。
部分机型出现部分用户登陆不了
谷歌提示链接：https://accounts.google.com/signin/rejected?rrk=46&hl=zh-CN
跟浏览器内核开发沟通，我们设置的内核版本太低了，我们设置UserAgent的时候，浏览器内核版本是固定死的，现在根据UserAgent动态设置。
默认的UserAgent为：Mozilla/5.0 (Linux; Android 10; 1913 Build/QP1A.190711.020; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/83.0.4103.106 Mobile Safari/537.36
    String chromeVersion = getChromeVersion();
    StringBuilder builder = new StringBuilder();
    builder.append("Mozilla/5.0 (Linux; Android ")
            .append(Build.VERSION.RELEASE)
            .append(";")
            .append(Locale.getDefault().getLanguage())
            .append(";")
            .append(Build.MODEL)
            .append(" Build/IMM76B) AppleWebKit/537.19 (KHTML, like Gecko) ")
            .append(chromeVersion)
            .append(" Mobile Safari/537.19");
private String getChromeVersion() {
    String chromeVersion = "Chrome/18.0.1025.133";
    if (mWv == null || mWv.getSettings() == null) {
        return chromeVersion;
    }
    String userAgent = mWv.getSettings().getUserAgentString();
    LogUtils.w(Logging.LOG_TAG, "getChromeVersion userAgent:" + userAgent);
    if (TextUtils.isEmpty(userAgent) || userAgent.indexOf("Chrome/") < 0) {
        return chromeVersion;
    }
    String chrome = userAgent.substring(userAgent.indexOf("Chrome/"));
    String[] userAgentArray = chrome.split(" ");
    if (userAgentArray == null || userAgentArray.length < 1) {
        return chromeVersion;
    }
    return userAgentArray[0];
}

### DialogFragment在弹框后，切换到别的界面或者黑屏，这个过程中间调用dismiss导致闪退。
需要复写它的两个方法。因为页面不可见的时候会执行SavedInstance方法，这时候的界面的不可控的。
    @Override
    public void dismiss() {
        if (isSavedInstance) {
            dismissAllowingStateLoss();
            return;
        }
        Activity activity = getActivity();
        if (null != activity && !activity.isFinishing()) {
            super.dismiss();
        }
    }
    @Override
    public void dismissAllowingStateLoss() {
        Activity activity = getActivity();
        // 部分机型在特殊情况下，DialogFragment在show状态，但是getDialog得到的Dialog是hide状态，dismissAllowingStateLoss内部也会有判断。
        if (null != activity && !activity.isFinishing()) {
            super.dismissAllowingStateLoss();
        }
    }

### 日志打印量太大，影响性能，每秒200行以上打印。
使用StringBuilder，在循环语句中进行拼接，再语句外打印StringBuilder。

### 深色模式下的变量问题。
a界面跳转b界面，b界面切换深色模式，a和b都会重新走页面的生命周期。会导致全局变量销毁的情况，产生问题。
在SavedInstance方法中保存和恢复。

### 下载大于int值字节的附件时，下载一半就不显示进度条。
int属于Java中的整型，长度为4字节32bit，取值-2^31 （-2,147,483,648）到 2^31-1（2,147,483,647），变量初始化默认值为0，包装类Integer
之前为：listener.loadProgress(pos * 100 / size); 
这里的pos * 100大于int最大值的时候，是负数。
现在改为：listener.loadProgress((int) (pos / (float) size * 100));

### AES/ECB/PKCS5Padding加密改为AES/CBC/PKCS5Padding
// AES加密算法、CBC(有向量模式)、PKCS5Padding: 加密内容不足8位用余位数补足8位
private static final String CRYPTION_CBC_ALGORITHM = "AES/CBC/PKCS5Padding";
// 密钥算法，java6支持56位密钥，bouncycastle支持64位 
public static final String KEY_ALGORITHM="AES";
之前的ECB加密模式太简单，不安全。
这里加密是针对字节数组加密，加密方和解密方的密钥和算法需要保持一致。
  /**
     * Description：CBC模式加密
     * @param data 待加密数据
     * @param key 密钥
     * @return 加密后的数据
     */
    public static byte[] encryptCBC(byte[] data, byte[] key) throws Exception {
        //还原密钥
        Key k = toKey(key);
        Cipher cipher = Cipher.getInstance(CRYPTION_CBC_ALGORITHM);
        //初始化，设置为加密模式
        cipher.init(Cipher.ENCRYPT_MODE, k, generateIV(key));
        //执行操作
        return cipher.doFinal(data);
    }
    /**
     * Description：CBC模式解密
     * @param data 待解密数据
     * @param key 密钥
     * @return 解密后的数据
     */
    public static byte[] decryptCBC(byte[] data, byte[] key) throws Exception {
        //还原密钥
        Key k = toKey(key);
        Cipher cipher = Cipher.getInstance(CRYPTION_CBC_ALGORITHM);
        //初始化，设置为解密模式
        cipher.init(Cipher.DECRYPT_MODE, k, generateIV(key));
        //执行操作
        return cipher.doFinal(data);
    }
    /**
     * 转换密钥 
     * @param key 二进制密钥 
     * @return Key 密钥 
     * */  
    public static Key toKey(byte[] key){
        return new SecretKeySpec(key, KEY_ALGORITHM);  
    }
    /**
     * Description：生成IvParameterSpec：规范加密的参数，使用CBC模式时必须传入该参数
     * @param key 密钥
     * @return 规范加密的参数，使用CBC模式时必须传入该参数
     */
    public static AlgorithmParameters generateIV(byte[] key) throws Exception {
        AlgorithmParameters params = AlgorithmParameters.getInstance(KEY_ALGORITHM);
        params.init(new IvParameterSpec(key));
        return params;
    }

### String转byte[]的时候出错
正常的转是没问题的：
String s = "好好学习，天天向上";
byte[] b = s.getBytes("utf-8");
String s1 = new String(bytes, "utf-8");
但是通过加密和解密后就不行了，因为加解密会对字节数组进行位移操作。
解决办法:
String s = "好好学习，天天向上";
byte[] b = s.getBytes("utf-8");
byte[] b1 = encrypt(b, KEY_BYTES);// 用私钥KEY_BYTES对字节数组b进行加密产生字节数组b1
String s1 = Base64.encodeToString(b1, Base64.DEFAULT);// 对加密后的字节数组b1进行Base64编码
String s2 = Base64.decode(s1, Base64.DEFAULT);// 对s1进行解码
byte[] b2 = decrypt(s2, KEY_BYTES);// 对解码后的s2进行解密
String s3 = new String(b2, "utf-8");// 现在得到的s3就是："好好学习，天天向上"

### 正则表达式内存溢出
表达式为：text =text.replaceAll("<!--(.|[\r\n])*?-->",""); // 去掉文本中的<!-- -->注释
报错：java.lang.OutOfMemoryError: Failed to allocate a 62101672 byte allocation with 6275072 free bytes and 40MB until OOM, max allowed footprint 232202520, growth limit 268435456
	at java.util.Arrays.copyOfRange(Arrays.java:3592)
修改原因：1、String.replaceAll-Matcher.replaceAll-StringBuffer.toString-Arrays.copyOfRange。2、异步多线程操作。3、正则表达式内存溢出。
解决方法：正则表达式用的StringBuffer会一直累加，现在改为字符串分块处理替换的方式。
    private static String replaceAllNotes(String text) {
        if (TextUtils.isEmpty(text)) {
            return "";
        }
        String[] notesArray = text.split(NOTES_START);
        if (notesArray == null) {
            return text;
        }
        int notesLength = notesArray.length;
        if (notesLength < 1) {
            return text;
        }
        for (int i = 0; i < notesLength; i++) {
            String notes = notesArray[i];
            if (!TextUtils.isEmpty(notes)) {
                int notesIndex = notes.indexOf(NOTES_END);
                if (notesIndex > -1) {
                    String replace = NOTES_START + notes.substring(0, notesIndex + NOTES_END.length());
                    if (!TextUtils.isEmpty(replace)) {
                        text = text.replace(replace, "");
                    }
                }
            }
        }
        return text;
    }

### 内存不够时，我们应用会自己销毁，需要判断是否前台进程再销毁
    private boolean isAppOnForeground() {
        ActivityManager activityManager = (ActivityManager) getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);
        if (activityManager == null) {
            return false;
        }
        List<ActivityManager.RunningAppProcessInfo> appProcesses = activityManager.getRunningAppProcesses();
        if (appProcesses == null || appProcesses.isEmpty()) {
            return false;
        }
        int pid = android.os.Process.myPid();
        for (ActivityManager.RunningAppProcessInfo appProcess : appProcesses) {
            if (appProcess != null && appProcess.pid == pid
                    && appProcess.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                return true;
            }
        }
        return false;
    }

### 广播anr
无序广播不会anr。
默认APP在发送广播时发送的是background broadcast。如果APP想要发送foreground broadcast，需要在准备发送的Intent中增加一个Flag，代码如下： intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
前台广播：当BroadcastReceiver在10秒内没有处理完该broadcast时，会触发ANR。Timeout的时间定义在：ActivityManagerService.BROADCAST_FG_TIMEOUT=10*1000;
后台广播：当BroadcastReceiver在60秒内没有处理完该broadcast时，会触发ANR。Timeout的时间定义在：ActivityManagerService. BROADCAST_BG_TIMEOUT =60*1000；
AMS在发送mOrderedBroadcasts队列中的broadcast给BroadcastReceiver时，会先判断该BroadcastReceiver所在的APP进程是否已存在，如果不存在，就会先创建该APP进程。并且，创建该APP进程所消耗的时间也算在Timeout时间之内。
(1) 导致BroadcastReceiver Timeout类型的ANR有三种情况：
*创建APP进程耗时太久，超过了Timeout时间。这种情况不多见。
*APP进程的Main Thread处理的事情太多，没有时间执行BroadcastReceiver. onReceive()方法。
*APP进程的Main Thread执行BroadcastReceiver. onReceive()过长。这种情况最多见。
(2)当出现BroadcastReceiver Timeout类型的ANR时，会打印以下信息：
BroadcastQueue: Timeout of broadcast BroadcastRecord{15f4f607 u0 com.tf.broadcastanrdemo} - receiver=android.os.BinderProxy@12d8940f, started 10000ms ago
BroadcastQueue: Receiver during timeout: BroadcastFilter{273fd6a5 u0 ReceiverList{15edcc9c 24578 com.example.testBroadcast.bctwo/10129/u0 remote:12d8940f}}
其中，蓝色和红色部分log会被具体的broadcast替代。从这两句log我们可以看出：APP进程(packageName= com.tf.broadcastanrdemo)在处理Action= com.example.testbroadcast.bctwo的broadcast时，发生了ANR。
注意：只有当发生ANR的APP进程中存在前台显示的Activity时，或者用户在’开发者选项’中将’显示所有“应用无响应”(ANR)’的选项选中，AMS才会弹出ANR对话框。否则AMS会直接杀掉该APP进程。
PS: 对于接收同一个广播，在相同优先级的情况下，动态注册优先级别高于静态注册。在动态注册中，最早动态注册优先级别最高；在静态注册中，最早安装的程序，静态注册优先级别最高

### IllegalArgumentException: parameter must be a descendant of this view
参考：https://www.cnblogs.com/monodin/p/3675040.html
如果被移除的View恰好是ViewGroup内当前焦点所在View，则清除焦点(clearChildFocus方法在清除焦点的同时也把ViewGroup内保存的Focused View引用清除)
if (view == null) {
    return;
}
if (view == findFocus()) {
    clearChildFocus(view);
}

### Cannot read property 'setItem' of null
js里面localStorage.setItem没有setItem方法
setDomStorageEnabled(true)开启外部存储
//给localStorage对象添加setItem方法
function addLocalStorageMethod() {
    Log("addLocalStorageMethod");
    if (!window) {
        Log("addLocalStorageMethod: window undefined");
        return
    }
    if (!window.localStorage) {
        Log("addLocalStorageMethod: window.localStorage undefined");
        window.localStorage = {}
    }
    try {
        if (!window.localStorage.setItem) {
            Log("addLocalStorageMethod: window.localStorage undefined2");
        }
        if("function" == typeof(window.localStorage.setItem)){
            return;
        }
    } catch(e) {
        Log("addLocalStorageMethod Exception1:"+e);
    }
    Log("addLocalStorageMethod: window.localStorage.setItem undefined");
    window.localStorage = {
        setItem: (function(key, value){
        })()
}

### NestedScrollView嵌套两个RecyclerView时，会有滑动不畅
* 让两个RecyclerView都不能滑动，跟随外部的ScrollView一起滑动
class NoScrollLayoutManager(context: Context?) : LinearLayoutManager(context) {
    override fun canScrollVertically(): Boolean {
        return false
    }
    override fun canScrollHorizontally(): Boolean {
        return false
    }
}

### 超长英文字体不能换行
overflow:hidden;word-wrap:break-word;word-break: break-all;

### 软键盘遮挡无内容提示
* 布局不随软键盘弹出而变化位置
android:windowSoftInputMode="stateVisible|adjustPan"
* TextView居中，ImageView位于TextView上方。

### [FATAL:crashpad_client_linux.cc(536)] Render process (9119)'s crash wasn't handled by all associated  webviews, triggering application crash.
[参考](https://stackoverflow.com/questions/46737984/onrenderprocessgonewebview-view-renderprocessgonedetail-detail-example)
使用mWebView.loadUrl("chrome://crash");测试，会复现这个异常。
多个WebView使用的是同一个RenderProcess（渲染进程），当渲染进程崩溃的时候，会回调WebViewClient的onRenderProcessGone方法，让应用自己处理该异常，需要返回true，否则也应用会崩溃。
继承WebViewClient，重写WebViewClient的onRenderProcessGone方法，使用WebView的地方都需要设置这个WebViewClient：
下面处理比较简单，实际处理应该为：
1、WebView外层包裹FrameLayout，移除的时候，获取getLayoutParams，然后重新设置添加到FrameLayout中。
2、WebView的WebSettings需要获取并重新设置。
3、WebView的其他属性需要获取并重新设置。
4、异常次数的判断处理和最终异常的处理。
@Override
public boolean onRenderProcessGone(WebView view, RenderProcessGoneDetail detail) {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
        return false;
    }
    super.onRenderProcessGone(view, detail);
    if (!detail.didCrash()) {
        if (view != null) {
            ((ViewGroup) view.getParent()).removeView(view);
            view.destroy();
            view = null;
        }
        return true;
    }
    return false;
}

### RxJava2的switchIfEmpty操作不了list == null || list.isEmpty()的情况
observable1.switchIfEmpty(observer2);
* 首先RxJava对list == null就有判空处理，直接报错的，所以observable1数据不能传null，内部判空new ArrayList()。
* list.isEmpty()时需要filter过滤处理
 observable1.filter(new Func1<List, Boolean>() {
    @Override
    public Boolean call(ArrayList list) {
        if (list == null || list.isEmpty()) {
            return true;// 注意返回true才是执行switchIfEmpty(observer2)的关键
        }
        return false;
    }
}).switchIfEmpty(observer2);

### 安卓判断网络连接mNetworkInfo.isAvailable()有问题，实际上有网络，而api却返回false。
public boolean isNetworkConnected(Context context) {  
    if (context == null) {
        return false;  
    }
    ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);  
    if (mConnectivityManager == null) {
        return false;  
    }
    NetworkInfo mNetworkInfo = mConnectivityManager.getActiveNetworkInfo();  // 获取当前活跃的网络信息，老的废弃了
    if (mNetworkInfo == null) {
        return false;  
    }
    // return mNetworkInfo.isAvailable();  // 网络是否可用，网上大多推荐这个api，其实不对，framwork有问题，会判断不准确。
    return mNetworkInfo.isConnected();  // 推荐使用这个api，网络是否连接
} 

### 安卓分区存储
* https://www.jianshu.com/p/271bbd13bfcf
公有目录：Downloads、Documents、Pictures 、DCIM、Movies、Music、Ringtones等，仍然使用READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE作为存储相关运行时权限。
地址：/storage/emulated/0/Downloads(Pictures)等公有目录下的文件不会跟随APP卸载而删除。
APP私有目录
地址：/storage/emulated/0/Android/data/包名/files
* 所有文件只能存放在私有目录或者安卓指定的公有目录,私有目录是随便存取的，共有目录只能通过特定api进行存取，特定目录的文件格式会发生改变，下载目录是.tmp格式文件，没法展示在图片列表。
* 问题复现步骤：安卓11.0-清除应用缓存-卸载应用-删除根目录文件夹-重新安装-下载文件-当调用到file.exists的时候是false，file.mkdirs的时候也是false。
解决：* 不适配：targetSdkVersion 28就行，如果是targetSdkVersion 29 就需要加上<android:requestLegacyExternalStorage="true">
* 需要跟需求确认是否适配分区存储，需要整理最新的方案。使用getContentResolver进行insert和openFileDescriptor和delete和openInputStream

### listview的dapter的控件不能点击
* adapter.notification()方法不断执行（一秒内执行很多次），导致不断刷新绘制，没法控件的点击事件
* 在这种特定情况下，遍历listview，只刷新对应adapter需要刷新的控件（进度条）

### SparseArray取值错误
SparseArray存的时候是put(key,value);，取的时候用的valueAt(position)，当position跟实际的不一致时，取值有误甚至异常。用get(key)进行替代了。

### 父控件不让子控件的点击事件生效。
* 所有子控件设置不能点击android:enabled = "false"
* 父控件onInterceptTouchEvent和onTouchEvent都返回true，消费掉事件。

### SharePreference
* SharePreferences不支持多进程
Google并不希望SharePreferences用于多进程，因为不安全，commit函数一般会在当前线程直接写文件，而apply则提交一个事务到已给线程池，之后直接返回。
SharePreferences在新建的有个mode参数，可以指定它的加载模式，MODE_MULTI_PROCESS是Google提供的一个多进程模式
* SharePreferences的commit与apply一个是同步一个是异步（大部分场景下）
* 不要使用SharePreferences存储太大的数据
读取xml配置，如果其他线程想要在读取之前就是用的话，就会被阻塞，一直wait等待，直到数据读取完成。--是同步的
使用xml解析工具XmlUtils，直接在当前线程读取xml文件，如果xml文件稍大，尽量不要在主线程读取，读取完成之后，xml中的配置项都会被加载到内存，再次访问的时候，其实访问的是内存缓存。

### SharePreference可以跨进程吗
* 跨进程一般使用ContentProvider，没有用过SharePreference进行跨进程。
* 网上说多进程不安全。
可以通过SharePreference先取出来，然后给ContentProvider分享。另外一个获取到后，进行存储。
* 非要用的流程：
- 清单文件的apllication配置android:sharedUserId="com.xxx"，需要共享的双方配置一样的sharedUserId
- 存值
SharedPreferences preferences = context.getSharedPreferences(USER_LISTS, Context.MODE_PRIVATE);
SharedPreferences.Editor edit = preferences.edit();
edit.putString(key, value);
edit.commit();
- 取值
Context pkgContext =null;
try {
    pkgContext =   createPackageContext("com.netease.nim.demo", CONTEXT_IGNORE_SECURITY);
} catch (PackageManager.NameNotFoundException e) {
}
if(pkgContext !=null){
    SharedPreferences preferences = pkgContext.getSharedPreferences("userlists", Context.MODE_MULTI_PROCESS);
    String userbeans = preferences.getString("userbeans", null);
}
- 注意事项：打包apk时，如果出现  INSTALL_FAILED_SHARED_USER_COMPATIBLE 错误提示，请确认已安装的应用已卸载（未添加sharedUserId版本）。
两个应用是否在使用同一个debug—keystone签名 

### 环境搭建
gradle.properties 中加入 android.enableAapt2=false，不建议
plugins {
  id 'com.android.library'
}
plugins {
  id 'com.android.application'
}
报错：Installed Build Tools revision 33.0.0 is corrupted. Remove and install again using the SDK Manager.
本地sdk有问题，改为32和31都不行，改为30.0.3后又报错
    //noinspection GradleCompatible,GradleCompatible
    compileSdkVersion 30
    buildToolsVersion "30.0.3"
Manifest merger failed : Apps targeting Android 12 and higher are required to specify
sdk的目标版本不一致，将compileSdkVersion和targetSdkVersion改为一致30

### 能运行的配置
    compileSdkVersion 30
    buildToolsVersion "30.0.3"

        minSdkVersion 24
        targetSdkVersion 30
        versionCode 1
        versionName "1.0"

app 无布局
implementation project(':mylibrary')
implementation project(':mylibrary2')

mylibrary 无布局
api 'androidx.appcompat:appcompat:1.2.0'
api 'com.google.android.material:material:1.2.1'
api 'androidx.constraintlayout:constraintlayout:2.0.1'

mylibrary2 有布局
compileOnly project(':mylibrary')

### npm run start 启动项目时出错：error:0308010C:digital envelope routines::unsupported
node版本太高导致，参考issue 须安装16.9及以下版本的nodejs，参考nodejs以往的版本
本地运行，在各自目录下执行命令即可： npm install npm run dev

### 在安卓11上获取不到applicationInfo
val applicationInfo: ApplicationInfo = base.packageManager.getApplicationInfo(
    "com.*.android",
    PackageManager.MATCH_UNINSTALLED_PACKAGES
)
val installedPackages =
   base.packageManager.getInstalledPackages(PackageManager.MATCH_UNINSTALLED_PACKAGES)
需要在AndroidManifest.xml中添加
    <queries>
        <package android:name="com.*.android" />
    </queries>
	
### 配置项目依赖	
修改模块名称
根目录内
def path = rootDir.parent + "/GBoxAppContainer/code/vmos-lite-sdk/"
if (localProject) {
    include ':vmos-lite-sdk'
    project(':vmos-lite-sdk').projectDir = new File(path + "vmos-lite-sdk")
}
根目录外
def liteAliasDir = new File(rootDir.parent, 'vmos-lite')
def liteAliasDir2 = new File(rootDir.parent, 'vmos-lite-sdk')
def liteRootDir = liteAliasDir.exists() ? liteAliasDir : liteAliasDir2
if (localProject && liteRootDir.exists()) {
    def subModules = ['sandhook', 'hiddenapi-stub', 'vmos-lite-sdk', 'vmos-lite-client',
                      'vmos-lite-base', 'vmos-lite-server', 'vmos-lite-native']
    subModules.each { name ->
        def subProjectDir = new File(liteRootDir, name)
        def includeName = ":$name"
        if (subProjectDir.exists() && subProjectDir.list().length > 0) {
            println("include ${includeName} -> ${subProjectDir.absolutePath}")
            include includeName
            project(includeName).projectDir = subProjectDir
        }
    }
}

### Android studio无法启动模拟器，报错：The emulator process for AVD hasterminated
* 查资料，配置环境变量：https://www.jianshu.com/p/fc278242453c
* C:\Users\admin\AppData\Local\Google\AndroidStudio2021.2\log下idea.log，提示：Please update the emulator to one that supports the feature(s): Vulkan
百度找不到，又搜索Failed to create Vulkan instance.
找到一个回答：https://stackoverflow.com/questions/61358662/failed-to-create-vulkan-instance-android-studio-windows-10
要下载英特尔的驱动：https://github.com/intel/haxm/releases
我下载了最新的，还是不行，studio提示了应该是7.6.5版本的
把最新的卸载，重新安卓7.6.5的就行了。

### android studio创建c++项目运行不了
需要下载visualstudio并搭建好开发环境。
https://visualstudio.microsoft.com/zh-hans/downloads/

### 反射framework层的api，反射不了
需要跳过隐藏api
implementation 'io.github.windysha:bypassHiddenApiRestriction:1.0.2'
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            HiddenApiBypass.startBypass();
    }

### 解决 tinkerId is not set!
https://blog.51cto.com/u_13045684/6106769
在gradle.properties中加入下面2行代码
TINKER_ID=1.0 TINKER_ENABLE=true

### 22.2以下的studio报：ModelCache.safeGet(androidProjectResult.androidProject::getNdkVersion, "") must not be null
http://www.manongjc.com/detail/61-zvptbzccmqmnqta.html#google_vignette
需要在local.properties设置NDK路径
sdk.dir=C\:\\Users\\1\\AppData\\Local\\Android\\Sdk
ndk.dir=C\:\\Users\\1\\AppData\\Local\\Android\\Sdk\\ndk\\25.2.9519653
添加完成后，又报：Both android.ndkPath and ndk.dir in local.properties are set
这个时候注释掉就可以
#ndk.dir=C\:\\Users\\1\\AppData\\Local\\Android\\Sdk\\ndk\\25.2.9519653

### 签名密钥问题
* 创建签名 https://www.jianshu.com/p/a1f8e5896aa2
* 查看签名信息： keytool -list -v -keystore C:\work\code\Ru5ZaLGoF.jks
* 输入密码，得到以下签名信息:
输入密钥库口令:
密钥库类型: JKS
密钥库提供方: SUN
您的密钥库包含 1 个条目
别名: sgqo7hm
创建日期: 2023年7月7日
条目类型: PrivateKeyEntry
证书链长度: 1
证书[1]:
所有者: CN=Sgqo7Hm
发布者: CN=Sgqo7Hm
序列号: 1243970b
生效时间: Fri Jul 07 15:07:37 CST 2023, 失效时间: Sun Jun 13 15:07:37 CST 2123
证书指纹:
         SHA1: 5A:93:9C:66:34:95:C8:F5:C1:BB:7D:61:2C:3B:2D:BB:71:1E:EC:52
         SHA256: B8:7C:8C:47:7F:0A:53:4C:1C:F7:9F:45:57:F4:33:6B:9D:84:00:28:E0:A9:FD:7A:7C:E9:96:C0:F0:20:48:85
签名算法名称: SHA1withRSA (弱)
主体公共密钥算法: 2048 位 RSA 密钥
版本: 3
扩展:
#1: ObjectId: 2.5.29.14 Criticality=false
SubjectKeyIdentifier [
KeyIdentifier [
0000: 1F 1C AC 18 93 91 67 92   9D 6D 1F DB 8C 8D B2 A1  ......g..m......
0010: 90 E1 9E E4                                        ....
]
]
* 已有签名，填写构建信息
Keystore不对
keyAlias Ru5ZaLGoF
keyPassword Ru5ZaLGoF
storePassword Ru5ZaLGoF
> com.android.ide.common.signing.KeytoolException: Failed to read key Ru5ZaLGoF from store "C:\work\code\github\Plugin\02A20230711_52_3-TeenPattiGo2047-1\build\android\proj\Ru5ZaLGoF.jks": 
Keystore was tampered with, or password was incorrect---密钥存储被篡改或密码不正确

Keystore对了
keyAlias s3xTerf
keyPassword s3xTerf
storePassword s3xTerf
 > com.android.ide.common.signing.KeytoolException: Failed to read key s3xTerf from store "C:\work\code\github\Plugin\02A20230711_52_3-TeenPattiGo2047-1\build\android\proj\Ru5ZaLGoF.jks": 
 No key with alias 's3xTerf' found in keystore C:\work\code\github\Plugin\02A20230711_52_3-TeenPattiGo2047-1\build\android\proj\Ru5ZaLGoF.jks---在密钥库中找不到别名为“s3xTerf”的密钥

keyAlias Sgqo7Hm
keyPassword Sgqo7Hm
storePassword s3xTerf
> com.android.ide.common.signing.KeytoolException: Failed to read key Sgqo7Hm from store "C:\work\code\github\Plugin\02A20230711_52_3-TeenPattiGo2047-1\build\android\proj\Ru5ZaLGoF.jks": 
Cannot recover key--无法恢复密钥

keyAlias Sgqo7Hm
keyPassword s3xTerf
storePassword s3xTerf
报错消失
即配置信息：keyAlias是key，keyPassword是密钥，storePassword是密钥










