### java内存模型，实际也是物理机，有运行的物理空间。
[具体参考](https://www.jianshu.com/p/15106e9c4bf3)
* java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，用来屏蔽掉java程序在各种不同的硬件和操作系统对内存的访问的差异，这样就可以实现java程序在各种不同的平台上都能达到内存访问的一致性。可以避免像c/c++程序可能在windows平台运行正常，而在linux平台却运行异常的问题。
* cpu-高速缓存-缓存协议-java内存
* CPU的运行计算速度是非常快的，而其他硬件比如IO，网络、内存读取等等，跟cpu的速度比起来是差几个数量级的。所以协调cpu和各个硬件之间的速度差异是非常重要的，要不然cpu就一直在等待，浪费资源。而在多核中，不仅面临如上问题，还有如果多个核用到了同一个数据，如何保证数据的一致性、正确性等问题。
* 解决这个问题，就需要遵循一定的协议，诸如MSI、MESI等协议。（解决高速缓存和java内存不一致的问题）
* 解决代码乱序执行问题:cpu对乱序执行之后的结果进行重组，保证结果的正确性，也就是保证结果与顺序执行的结果一致。
* java内存里面：java线程-线程工作内存-读写操作-主内存。（这里的java内存跟java内存区域的堆、栈、方法区是不同情况的划分。）
* java线程是指java的多线程。
* 读写操作：java虚拟机中主内存和工作内存交互，就是一个变量如何从主内存传输到工作内存中，如何把修改后的变量从工作内存同步回主内存。
lock(锁定):作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量
unlock(解锁):作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定
read(读取):作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用
load(载入):作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)
use(使用):作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作
assign(赋值):作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作
store(存储):作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用
write(写入):作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中
* 原子性:同一时间只能一个线程操作。
* 可见性：一个线程修改了一个变量的值后，其他线程立即可以感知到这个值的修改。
* 顺序性：在本线程内部观察，所有操作都是有序的。


### 异常执行流程
try {
  System.out.println("try");
  return "return try";
} catch (Exception e) {
  System.out.println("return Exception");
  return "return Exception";
} finally {
  System.out.println("finally");
  return "return finally";
}
* finally是通过汇编直接嵌套在try和catch执行完毕的return前面的。
* finally里面有return，执行顺序为：try finally return finally
* finally没有return，执行顺序为：try finally return try
* catch是在try执行过程中出现异常，进行捕获的。没有异常不会执行catch的内容。

### 多线程
* 当多线程只读的时候是不需要加锁的，不会对数据造成影响。
* 多线程写安全问题，才会加锁，进行线程同步。避免线程1写一点的时候，线程2再写一点，线程1再写的时候就会覆盖线程2写的内容。产生脏数据（数据异常）。
* 多线程写也可以不加锁，可以分段写，例如一个文件，划分文件1，文件2...，线程1写文件1，线程2写文件2...，统计写入进度。都完成后，再整合成一个文件。
* 尽量避免全局锁，因为锁太大，导致持有这个锁的所有方法都要等待锁的释放，耗时。所以在需要的地方进行加锁，确保性能。
* 多线程并发性能问题，一个用户10个线程访问后台，十个用户同时访问后台的时候。导致服务器压力增大（从数据库取数据），这时候需要加缓存，减轻数据库的压力，数据库只需要进行同步更新。
* 多线程读会有性能问题，多线程并发会激增性能问题。多线程写会造成性能和安全问题。
* 多线程的核心：原子性，指令有序性和线程可见性。
* 原子性和事务的原子性一样，对于一个操作或者多个操作，要么都执行，要么都不执行。
* 指令有序性是指，在我们编写的代码中，上下两个互不关联的语句不会被指令重排序。
* 线程可见性是指一个线程修改了某个变量，其他线程能马上知道。解释：每个线程都有单独的工作空间，所有线程处于同一个工作空间，线程和线程之间通过公共空间进行调度。

### 锁
* synchronized静态方法的锁对象是静态方法所在的类，非静态方法的锁对象是创建调用该方法的new对象。
* 多线程写安全问题，才会加锁，进行线程同步。避免线程1写一点的时候，线程2再写一点，线程1再写的时候就会覆盖线程2写的内容。产生脏数据（数据异常）。
* 尽量避免全局锁，因为锁太大，导致持有这个锁的所有方法都要等待锁的释放，耗时。所以在需要的地方进行加锁，确保性能。
* 悲观锁，一个线程占用了一个锁，而导致其他所有需要这个锁的线程进入等待，一直到该锁被释放。
* 乐观锁，抱着尝试的态度去执行某项操作，如果操作失败或者操作冲突，那么就进入重试。
* 无锁算法，如CAS算法（比较再交换）：内存值a，旧的预期值b，要修改的新值c。当且仅当预期值b和内存值a相同时，将内存值a修改为c，否则什么都不做。

### 线程停止
线程的stop方法被废弃掉了，因为不安全，当多线程操作同一个内存的时候，调用stop会导致内存写入状态异常，其他线程操作这一块内存的时候，也会异常。
* 让线程自然的执行完毕
* 使用中断，需要中断线程的地方执行thread.interrupt();线程内部try该异常或者interrupted()方法判断是否中断，是的话，进行内存销毁释放操作。
* 自己设置boolean标志来暂停。前面加volatile




































