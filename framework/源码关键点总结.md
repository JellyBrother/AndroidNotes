## Framework
### 1Android系统架构 https://www.sukaidev.top/2021/05/14/7ca6484e/
* 应用层（System Apps）
* javaFramework
* C++Framework（native）
* HAL
* Linux Kernel
* Loader
#### 几个关键进程
* Init进程
启动电源以及系统系统：当电源按下时引导芯片代码从预定义的地方（固化在 ROM）开始执行。加载引导程序BootLoader到RAM中，然后执行。
引导程序BootLoader：引导程序BootLoader是在Android操作系统开始运行前的一个小程序，它的主要作用是把系统OS拉起来并运行。
Linux Kernel启动：当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。在内核完成系统设置后，它首先在系统文件中寻找init.rc文件，并启动init进程。
Init 进程启动：init进程做的工作比较多 ，主要用来初始化和启动属性服务，也用来启动 Zygote 进程。
* Zygote进程：init.zygote64_32.rc文件包含两个service指令，对应两个Zygote进程。
第一个Zygote进程：进程名为zygote，进程通过/system/bin/app_process64来启动，并且会创建一个名为zygote的socket。
第二个Zygote进程：进程名为zygote_secondary，进程通过/system/bin/app_process32来启动，并且会创建一个名为zygote_secondary的socket。
zygote_secondary调用Java层ZygoteInit类的main函数，进入Java世界。
ZygoteConnection#handleChildProc--RuntimeInit#findStaticMain，入参className是"android.server.SystemServer"
ZygoteInit.java类，找到对应的Java main方法，此方法的主要工作为：
预加载类和资源：预加载的类都是Android中的一些关键类，整个列表定义在frameworks/base/config/preloaded-classes中，Android 10中一共有1万多个。资源主要是加载framework-res.apk中的资源、openGL以及WebView等，我们经常用的android.R文件就是来自这里。这些资源被保存到全局变量Resources中，它是一个全局静态变量，可以通过 Resources.getSystem() 来使用它。
创建服务端Socket
fork并启动SystemServer进程
开启循环，等待客户端请求
* SystemServer进程
进程名为“system_server”：主要用于创建系统服务，我们熟知的 AMS、ATMS、WMS 和 PMS 都是由它来创建的。
设置一大堆虚拟机的系统属性
清除JVM中的内存增长上限
设置binder线程池最大线程数，Android 10里面为31，启动Binder线程池，用于与其他进程进行Bind通信。
创建SystemServer进程的主线程Looper
加载android_servers.so库，初始化Native服务
创建系统上下文
创建系统管理服务
启动引导服务
启动核心服务
启动其他服务
#### 问答
* Q：系统服务何时启动？如何启动？
A：在SystemServer进程启动时，会分批启动所有系统服务。
通过SystemServiceManager#startService来启动一个服务，服务启动后需要注册到ServiceManager中，其他进程访问ServiceManager来获取服务的代理对象。
* Q：什么是Zygote预加载？
A：预加载是指在Zygote进程启动的时候就加载一些类库和资源文件，这样系统只需要在第一次启动Zygote时加载这些共用的资源，子进程创建时只需要复用即可无需再次加载。
这些资源被保存到全局变量Resources中，它是一个全局静态变量，可以通过 Resources.getSystem() 来使用它。
全局资源Resources
* Q：系统中有几个Zygote进程？
A：按照我们上面的源码分析，系统中有两个Zygote进程，进程名分别为zygote和zygote64。
但如果我们使用adb shell ps查看真机上的进程时，会发现多了一个名为webview_zygote的进程，有时候还会有一个名为App包名_zygote的进程。
这两个进程实际上是由ZygoteProcess#startChildZygote创建而来，这些进程继承了Zygote中的数据，并且可以与Zygote连接。
创建它们的目的通常是明确的，例如WebViewZygtoe用于启动一个WebView进程。
不过按照通常意义来讲的Zygote进程最少一个最多两个。
* Q：为什么SystemServer与Zygote进程之间的通信采用Unix Domain Sockt而不是Binder？
A：关键的原因有：
fork采用的是CopyOnWrite机制，由于可能存在的死锁问题，Unix禁止fork多线程程序。Zygote当然也是多线程的，除了主线程外还有4条守护线程，每次fork前都需要停止这些线程，待fork结束后重新执行。
Zygote进程先于SystemServer创建，如果要使用Binder，那么需要等待SystemServer创建完成之后再向SystemServer注册Binder服务，这里需要额外的同步操作。
Binder机制是需要建立Binder线程池的，代理对象对Binder的调用是在Binder线程池中，在通过线程间通信通知主线程。
例如Activity启动时，AMS的本地代理IApplicationThread运行在Binder线程池中，处理完毕后通过Handler通知ActivityThread来执行启动Activity的流程。
Zygote本身只需与SystemServer以及子Zygote进程通信，并不依赖多线程来提升性能，若使用Binder反而增加了Zygote中的线程数，使得性能下降。

### 2Activity的启动流程 https://www.sukaidev.top/2021/05/22/4cb0a496/
* Launcher 请求 ATMS 过程
Launcher 我们可以点击图标启动任何一个App，继而启动它的 Main Activity。整个过程发生在Launcher#startActivitySafely--BaseDraggingActivity#startActivitySafely
Activity#startActivity--Activity#startActivityForResult--Instrumentation#execStartActivity--ActivityTaskManagerService#startActivity
startActivity 最终都会调用到 startActivityForResult，而启动一个 Activity 必须通过系统服务来执行，因此会使用 Launcher 的 ApplicationThread 来发起一次 IPC 调用，最终在 Instrumentation#execStartActivitiesAsUser 中请求 ATMS 来启动 Activity。
* ATMS 调用 ApplicationThread 过程
ActivityTaskManagerService#startActivity--ActivityTaskManagerService#startActivityAsUser--ActivityStarter#execute--ActivityStarter#startActivityMayWait--
ActivityStarter#startActivity--ActivityStarter#startActivityUnchecked--RootActivityContainer#resumeFocusedStacksTopActivities--ActivityStack#resumeTopActivityUncheckedLocked--
ActivityStack#resumeTopActivityInnerLocked--ActivityStackSupervisor#startSpecificActivityLocked--ActivityStackSupervisor#realStartActivityLocked--
ClientLifecycleManager#scheduleTransaction--ApplicationThread#scheduleTransaction
首先ATMS会判断权限信息，只有具有权限的调用进程才可以启动Activity。
接着ActivityStarter解析Intent的内容，创建对应的ActivityRecord对象，根据是否需要新建Task来新建或者选择对应的TaskRecord添加Activity，并处理Task相关状态信息，例如前后台的转移。
然后就会使前台Task的栈顶Activity可见，这个过程就会启动对应的Activity，必要情况会启动对应的进程。
最后通过IPC调用将启动Activity的事务发送到对应进程中，交由对应App来处理。
* ActivityThread启动Activity过程
ApplicationThread#scheduleTransaction--ClientTransactionHandler#scheduleTransaction--ActivityThread#sendMessage--H#handleMessage--TransactionExecutor#execute--
TransactionExecutor#executeCallbacks--LaunchActivityItem#execute--ActivityThread#handleLaunchActivity--ActivityThread#performLaunchActivity
ApplicationThread接收到ATMS发送过来的事务，通过Handler发送到主线程处理。
ActivityThread内部Handler（H）处理消息，并将事务交给TransactionExecutor处理。
TransactionExecutor执行事务的所有Callback，继而执行ActivityThread#handleLaunchActivity。
ActivityThread#handleLaunchActivity调用performLaunchActivity方法来执行核心逻辑。
ActivityThread#performLaunchActivity中反射创建的Activity实例，并且调用了attach方法绑定一些信息，然后调用callActivityOnCreate执行Activity生命周期。
* 总结:
- Launcher进程：通过点击图标生成Intent，使用Binder通信通知ATMS启动对应Activity。
- SystemServer进程：
检查调用（Launcher）进程是否被隔离、是否有权限启动Activity，然后生成ActivityStarter来处理Activity启动事宜。
ActivityStackSupervisor#startSpecificActivityLocked会创建对应app进程，ActivityStackSupervisor#realStartActivityLocked会启动对应app的界面
解析Intent中的信息，通过这些信息解析出包含Activity信息的ActivityInfo对象。判断Activity是否有在清单文件中注册、是否有权限等。
计算Intent的Flags，处理LaunchMode问题，判断Activity的目标任务栈，将Activity添加到任务栈中。
将任务栈移至前台，使栈顶的Activity可见，会创建一个事务并通过Binder调用发送到目标App进程。
如果App进程不存在，通过Socket通知Zygote进程启动App进程。
- 应用程序进程：
接收SystemServer传递的事务并且执行事务。
ApplicationThread接收到ATMS发送过来的事务，通过Handler发送到主线程处理。
ActivityThread内部Handler（H）处理消息，并将事务交给TransactionExecutor处理。
TransactionExecutor执行事务的所有Callback，继而执行ActivityThread#handleLaunchActivity。
ActivityThread#handleLaunchActivity调用performLaunchActivity方法来执行核心逻辑。
ActivityThread#performLaunchActivity中反射创建的Activity实例，并且调用了attach方法绑定一些信息，然后调用callActivityOnCreate执行Activity生命周期。
反射创建Activity对象，为Activity创建Context、Window等。
回调其onCreate、onStart、onResume生命周期。
- Zygote进程：接收SystemServer的消息通过Fork自身来创建App进程

### 3应用程序进程启动流程 https://www.sukaidev.top/2021/06/03/31b8eb1c/
* AMS发送创建App进程请求ActivityStackSupervisor#startSpecificActivityLocked--
PooledLambda#obtainMessage--ActivityManagerInternal#startProcess--ActivityManagerService$LocalService#startProcess--ActivityManagerService#startProcessLocked--
ProcessList#startProcessLocked--ProcessList#startProcess--Process#start--ZygoteProcess#start--ZygoteProcess#startViaZygote--ZygoteProcess#zygoteSendArgsAndGetResult--开启无限循环以等待子进程的请求
* Zygote接收请求并创建App进程
ZygoteServer#runSelectLoop--ZygoteConnection#processOneCommand--Zygote#forkAndSpecialize--Daemons#stop停止四个守护线程(Java堆内存整理线程：HeapTaskDaemon、引用队列处理线程：ReferenceQueueDaemon、执行finalize()方法的析构线程：FinalizerDaemon、析构方法监控线程：FinalizerWatchdogDaemon)等待并确保Zygote是单线程
Zygote进程中，主要做了以下工作：
Zygote通过Socket接收到SystemServer传递过来的创建进程请求。
Zygote通过Zygote.forkAndSpecialize方法创建子进程，这又分为几个步骤：
preFork：停止Zygote中的4条守护线程，预初始化JIT和GC堆。
nativeForkAndSpecialize：调用fork()函数来创建新进程，设置新进程的gid、主线程的tid，重置GC数据，设置信号处理函数，启动JDWP线程等。
postForkCommon：重新启动停止的4条守护线程并通知JIT。
* App进程初始化。
fork完成之后，子进程进入ZygoteConnection#handleChildProc--RuntimeInit#findStaticMain，入参className是"android.app.ActivityThread"
从handleChildProc()方法进入App进程的执行，初始化Binder驱动、创建Binder线程池，设置ART虚拟机的参数，反射调用Java main方法，开启消息循环。

### 4分析ActivityManagerService https://www.sukaidev.top/2021/06/16/8695f279/
* AMS启动过程
SystemServer#run--SystemServer#startBootstrapServices--ActivityManagerService#Lifecycle#startService--SystemServiceManager#startService--
ActivityManagerService的构造函数初始化--
Activity用ActivityTaskManagerService初始化
Service用ActiveServices类来管理，用ServiceRecord来记录：前台服务10秒超时、普通服务20秒超时、后台服务200秒超时。
ContentProvider用ProviderMap类来管理，用ContentProviderRecord来记录。
Broadcast用FgBroadcastQueue、BgBroadcastQueue、OffloadBroadcastQueue来管理，前台广播10秒超时、后台广播60秒超时、延时广播60秒超时。
--ActivityManagerService#start--
* AMS中重要的数据结构
ActivityRecord:存储了Activity的所有信息
TaskRecord:一个Activity任务栈
ActivityStack:管理Activity的任务栈
* ActivityStackSupervisor
ActivityStackSupervisor是Android系统中Activity的终极大管家，本身不直接持有ActivityStack的引用，而是通过持有RootActivityContainer间接持有ActivityDisplay引用，进而间接管理ActivityStack。


### 5分析Activity在各个生命周期阶段的主要工作 https://www.sukaidev.top/2021/07/15/e90b373e/
* attach方法为Activity注入外部环境的一些对象，其中为Activity创建了Window。
* Create阶段，这里会分为三个步骤：
prePerformCreate：执行在Activity#onCreate之前，完成一些预处理
performCreate：回调Activity#onCreate方法
postPerformCreate：执行在Activity#onCreate之后，完成一些收尾工作
Instrumentation#prePerformCreate
* Start阶段
执行完ActivityThread中的performLaunchActivity方法之后，Activity就已经被成功启动，不过此时Activity还处于ON_CREATE状态，而我们是希望此Activity的目标状态（Target State）是ON_RESUME，那么我们还需要顺序的执行Activity的生命周期回调onStart和onResume。
执行完LaunchActivity这个事务后，在cycleToPath方法中，调用了TransactionExecutorHelper中的getLifecyclePath得到了一个IntArray，此IntArray中存储了需要顺序执行的生命周期。在performLifecycleSequence方法中遍历这个集合，去执行后续的ON_START、ON_RESUME生命周期。
ON_START会执行handleStartActivity方法,执行performStart方法，主要是分发preStart事件、调用onStart、分发postStart事件。
performStart后会考虑是否要调用onRestoreInstanceState来恢复数据
* Resume阶段
执行handleResumeActivity方法，会判断此Activity的Window是否已经添加到WindowManager中，以及是否是真正需要显示的。如果是要显示的并且还未添加，那么将会调用WindowManager的addView方法来讲将decor添加到WindowManager中，并调用了requestLayout方法来发起整个View树的测量、布局与绘制工作。。
* Pause阶段
handlePauseActivity方法表示自此Pause事件是由于用户导致，例如按下back键、home键、点击跳转Activity等。
* Stop阶段
handleStopActivity方法调用了performStopActivityInner来处理Activity的Stop状态，并且在Stop之后隐藏了Activity的DecorView的显示。
* onSaveInstanceState方法。
在Android Honeycomb之前，onSaveInstanceState在onPause调用之前被调用
在Android Honeycomb之后，Android P之前，onSaveInstanceState在onStop调用之前被调用
在Android P之后，onSaveInstanceState在onStop调用之后被调用
* Destroy阶段
App除了要完成Activity本身的销毁逻辑外，还需要通知System Server来处理Activity栈相关的逻辑。

### Android原生应用的绘制渲染流程 https://www.sukaidev.top/2022/06/28/f4c089aa/
* Input事件处理机制
- 系统机制分析
Input 事件驱动，其中的核心就是 InputReader 和 InputDispatcher。InputReader 和 InputDispatcher 是跑在 system_server进程中的两个 Native循环线程，负责读取和分发 Input 事件。
触摸屏会按照屏幕硬件的触控采样率周期，每隔几毫秒扫描一次，如果有触控事件就会上报到对应的设备驱动；系统封装了一个叫EventHub的对象，它利用inotify和epoll机制监听/dev/input目录下的input设备驱动节点，通过EventHub的getEvents接口就可以监听并获取到Input事件；
InputReader负责从EventHub里面把Input事件读取出来，然后交给 InputDispatcher 进行事件分发；
InputDispatcher在拿到 InputReader获取的事件之后，对事件进行包装后，通过IMS寻找并分发到目标窗口(通过WMS找到Activity的ViewRootImpl);
InboundQueue队列（“iq”）中放着InputDispatcher从InputReader中拿到的input事件；
OutboundQueue（“oq”）队列里面放的是即将要被派发给各个目标窗口App的事件；
WaitQueue队列里面记录的是已经派发给 App（“wq”），但是 App还在处理没有返回处理成功的事件；
PendingInputEventQueue队列（“aq”）中记录的是应用需要处理的Input事件，这里可以看到input事件已经传递到了应用进程；
deliverInputEvent 标识 App UI Thread 被 Input 事件唤醒；
InputResponse 标识 Input 事件区域，这里可以看到一个 Input_Down 事件 + 若干个 Input_Move 事件 + 一个 Input_Up 事件的处理阶段都被算到了这里；
App 响应处理Input 事件，内部会在其界面View树中逐层分发和处理。5秒内没有处理则报ANR。
- 结合Systrace分析
1、system_server进程的处理过程：
当用户手指在Setting应用界面滑动时，系统system_server进程中的native线程InputReader会从EventHub中读取其利用linux的epoll机制监听到的屏幕驱动上报的Input触控事件，然后唤醒另外一条native线程InputDispatcher负责进行事件的进一步分发处理。
InputDispatcher被唤醒后会先将事件放到InboundQueue队列（也就是Systrace上看到的“iq”队列）中，然后找到具体处理此input事件的应用目标窗口，并将Input事件放入对应的应用目标窗口的OutboundQueue队列（也就是Systrace上看到的“oq”队列）中，等待进一步通过SocketPair双工信道发送input事件到应用目标窗口中；
最后当事件发送给具体的应用目标窗口后，会将事件移动到WaitQueue队列中（也就是Systrace上看到的“wq”队列）并一直等待收到到目标应用处理Input事件完成后的反馈后再从队列中移除，如果5秒内没有收到目标应用窗口处理完成此次Input事件的反馈，就会报该应用ANR异常事件
2、应用进程的处理过程：
先交给之前在添加应用PhoneWindow窗口时的ViewRootImpl#setView流程中创建的多个不同类型的InputUsage中依次进行处理（比如对输入法处理逻辑的封装ImeInputUsage，某些key类型的Input事件会由它先交给输入法进程处理完后再交给应用窗口的InputUsage处理），整个处理流程是按照责任链的设计模式进行；
然后交给负责应用窗口Input事件分发处理的ViewPostImeInputUsage中具体处理，这里面会从View布局树的根节点DecorView开始遍历整个View树上的每一个子View或ViewGroup控件执行事件的分发、拦截、处理的逻辑；
最后触控事件处理完成后会调用ViewRootImpl#finishInputEvent结束应用对触控事件处理逻辑，这里面会通过JNI调用到native层InputConsumer的sendFinishedSignal函数中通过socket消息通知系统框架中的InputDispatcher该Input事件处理完成，触发从"wq"队列中及时移除待处理事件以免报ANR异常。
一次滑动过程的触控交互的InputResponse区域中一般会包含一个Input的ACTION_DOWN事件+多个ACTION_MOVE事件+一个ACTION_UP事件，Settings应用界面中的相关View控件在收到多个ACTION_MOVE触控事件后，经过判断为用户手指滑动行为，一般会调用View#invalidate等相关接口触发UI线程的绘制上帧更新画面的操作
* 应用UI线程消息循环机制
主线程的ActivityThread执行其main函数，进行UI主线程的初始化工作
主线程初始化完成后，主线程就有了完整的 （Handler、Looper、MessageQueue、Message），此时 ActivityThread 的 Handler 就可以开始处理 Message，包括 Application、Activity、ContentProvider、Service、Broadcast 等组件的生命周期函数，都会以 Message 的形式，在主线程按照顺序处理，这就是 App 主线程的初始化和运行原理。
主线程初始化完成后，主线程就进入阻塞状态（进入epoll_wait状态，并释放CPU运行资源），等待 Message，一旦有 Message 发过来，主线程就会被唤醒，处理 Message。可以说Android系统的运行是受消息机制驱动的，而整个消息机制是由上面所说的四个关键角色相互配合实现的（Handler、Looper、MessageQueue、Message）
* Android屏幕刷新机制
- 双缓存+Vsync
包括CPU、GPU、Display三个部分：CPU负责计算帧数据，把计算好的数据交给GPU，GPU会对图形数据进行渲染，渲染好后放到buffer(图像缓冲区)里存起来，然后Display（屏幕或显示器）负责把Buffer里的数据呈现到屏幕上。
CPU：代表利用CPU对界面View的Measure尺寸测量、Layout位置布局、Draw绘制并最终生成纹理的操作；
GPU：代表使用OpenGl库指令操作GPU硬件对CPU生成的纹理数据进行渲染和栅格化以及合成等操作；
Display：代表底层的显示屏幕；
双缓冲：让绘制和显示器拥有各自的Buffer：CPU/GPU 始终将完成的一帧图像数据写入到 后缓存区（Back Buffer），而显示器使用前缓存区（ Front Buffer），当屏幕刷新时，Front Buffer 并不会发生变化，当Back Buffer准备就绪后，它们才进行交换。
屏幕的显示节奏是由屏幕刷新率的硬件参数决定且固定的，软件操作系统需要配合屏幕的显示，在固定的时间内准备好下一帧，以供屏幕进行显示，两者通过垂直同步VSync信号来实现同步。
- Choreographer（中文翻译为“编舞者”）
View#invalidate触发更新视图请求，此动作会调用ViewRootImpl#scheduleTraversals函数；
ViewRootImpl#scheduleTraversals中会向Choreographer中postCallback放入一个CALLBACK_TRAVERSAL类型绘制待执行任务；
Choreographer通过DisplayEventReceiver向系统SurfaceFlinger注册下一个VSync信号;
当底层产生下一个VSync消息时，将该信号发送给DisplayEventReceiver，最后传递给Choreographer；
Choreographer收到VSync信号之后，向主线程MessageQueue发送了一个异步消息；
最后，异步消息的执行者是跑在主线程中的ViewRootImpl#doTraversal，也就是真正开始绘制一帧的操作（包含measure、layout、draw三个过程）；
*  UI 线程绘制流程
Window是一个抽象类，通过控制DecorView提供了一些标准的UI方案，比如背景、标题、虚拟按键等，而PhoneWindow是Window的唯一实现类，在Activity创建后的attach流程中创建，应用启动显示的内容装载到其内部的mDecor（DecorView）；
DecorView是整个界面布局View控件树的根节点，通过它可以遍历访问到整个View控件树上的任意节点；
WindowManager是一个接口，继承自ViewManager接口，提供了View的基本操作方法；WindowManagerImp实现了WindowManager接口，内部通过组合方式持有WindowManagerGlobal，用来操作View；WindowManagerGlobal是一个全局单例，内部通过ViewRootImpl将View添加至窗口中；
ViewRootImpl是所有View的Parent，用来总体管理View的绘制以及与系统WMS窗口管理服务的IPC交互从而实现窗口的开辟；ViewRootImpl是应用进程运转的发动机，可以看到ViewRootImpl内部包含mView（就是DecorView）、mSurface、Choregrapher：mView代表整个控件树，mSurfacce代表画布，应用的UI渲染会直接放到mSurface中，Choregorapher使得应用请求vsync信号，接收信号后开始绘制流程。
ViewRootImpl中负责的整个应用界面绘制的主要流程如下：
从界面View控件树的根节点DecorView出发，递归遍历整个View控件树，完成对整个View控件树的measure测量操作，由于篇幅所限，本文就不展开分析这块的详细流程；
界面第一次执行绘制任务时，会通过Binder IPC访问系统窗口管理服务WMS的relayout接口，实现窗口尺寸的计算并向系统申请用于本地绘制渲染的Surface“画布”的操作（具体由SurfaceFlinger负责创建应用界面对应的Layer对象，并通过内存共享的方式通过Binder将地址引用透过WMS回传给应用进程这边）；
从界面View控件树的根节点DecorView出发，递归遍历整个View控件树，完成对整个View控件树的layout布局操作；
从界面View控件树的根节点DecorView出发，递归遍历整个View控件树，完成对整个View控件树的draw绘制操作，如果开启并支持硬件绘制加速（从Android 4.X开始谷歌已经默认开启硬件加速），则走GPU硬件绘制的流程，否则走CPU软件绘制的流程；










